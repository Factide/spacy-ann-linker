{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"spaCy ANN Linker, a pipeline component for generating spaCy KnowledgeBase Alias Candidates for Entity Linking. Documentation : https://microsoft.github.io/spacy-ann-linker Source Code : https://github.com/microsoft/spacy-ann-linker spaCy ANN Linker is a spaCy a pipeline component for generating alias candidates for spaCy entities in doc.ents . It provides an optional interface for linking ambiguous aliases based on descriptions for each entity. The key features are: Easy spaCy Integration : spaCy ANN Linker provides completely serializable spaCy pipeline components that integrate directly into your existing spaCy model. CLI for simple Index Creation : Simply run spacy_ann create_index with your data to create an Approximate Nearest Neighbors index from your data, make an ann_linker pipeline component and save a spaCy model. Built in Web API for easy deployment and Batch Entity Linking queries Requirements \u00b6 Python 3.6+ spaCy ANN Linker is convenient wrapper built on a few comprehensive, high-performing packages. spaCy nmslib (ANN Index) . nmslib (ANN Index) . scikit-learn (TF-IDF) . FastAPI (Web Service) . Installation \u00b6 $ pip install spacy-ann-linker ---> 100% Successfully installed spacy-ann-linker Data Prerequisites \u00b6 To use this spaCy ANN Linker you need pre-existing Knowledge Base data. spaCy ANN Linker expects data to exist in 2 JSONL files together in a directory kb_dir \u2502 aliases.jsonl \u2502 entities.jsonl For testing the package, you can use the example data in examples/tutorial/data examples/tutorial/data \u2502 aliases.jsonl \u2502 entities.jsonl entities.jsonl Record Format \u00b6 { \"id\" : \"Canonical Entity Id\" , \"description\" : \"Entity Description used for Disambiguation\" } Example data { \"id\" : \"a1\" , \"description\" : \"Machine learning (ML) is the scientific study of algorithms and statistical models...\" } { \"id\" : \"a2\" , \"description\" : \"ML (\\\"Meta Language\\\") is a general-purpose functional programming language. It has roots in Lisp, and has been characterized as \\\"Lisp with types\\\".\" } { \"id\" : \"a3\" , \"description\" : \"Natural language processing (NLP) is a subfield of linguistics, computer science, information engineering, and artificial intelligence concerned with the interactions between computers and human (natural) languages, in particular how to program computers to process and analyze large amounts of natural language data.\" } { \"id\" : \"a4\" , \"description\" : \"Neuro-linguistic programming (NLP) is a pseudoscientific approach to communication, personal development, and psychotherapy created by Richard Bandler and John Grinder in California, United States in the 1970s.\" } ... aliases.jsonl Record Format \u00b6 { \"alias\" : \"alias string\" , \"entities\" : [ \"list\" , \"of\" , \"entity\" , \"ids\" ], \"probabilities\" : [ 0.5 , 0.5 ]} Example data { \"alias\" : \"ML\" , \"entities\" : [ \"a1\" , \"a2\" ], \"probabilities\" : [ 0.5 , 0.5 ]} { \"alias\" : \"Machine learning\" , \"entities\" : [ \"a1\" ], \"probabilities\" : [ 1.0 ]} { \"alias\" : \"Meta Language\" , \"entities\" : [ \"a2\" ], \"probabilities\" : [ 1.0 ]} { \"alias\" : \"NLP\" , \"entities\" : [ \"a3\" , \"a4\" ], \"probabilities\" : [ 0.5 , 0.5 ]} { \"alias\" : \"Natural language processing\" , \"entities\" : [ \"a3\" ], \"probabilities\" : [ 1.0 ]} { \"alias\" : \"Neuro-linguistic programming\" , \"entities\" : [ \"a4\" ], \"probabilities\" : [ 1.0 ]} ... spaCy prerequisites \u00b6 If you don't have a pretrained spaCy model, download one now. The model needs to have vectors so download a model bigger than en_core_web_sm $ spacy download en_core_web_md ---> 100% Successfully installed en_core_web_md Usage \u00b6 Once you have your data, and a spaCy model with vectors, compute the nearest neighbors index for your Aliases. Run the create_index help command to understand the required arguments. $ spacy_ann create_index --help spacy_ann create_index --help Usage: spacy_ann create_index [OPTIONS] MODEL KB_DIR OUTPUT_DIR Create an ApproxNearestNeighborsLinker based on the Character N-Gram TF- IDF vectors for aliases in a KnowledgeBase model (str): spaCy language model directory or name to load kb_dir (Path): path to the directory with kb entities.jsonl and aliases.jsonl files output_dir (Path): path to output_dir for spaCy model with ann_linker pipe kb File Formats e.g. entities.jsonl {\"id\": \"a1\", \"description\": \"Machine learning (ML) is the scientific study of algorithms and statistical models...\"} {\"id\": \"a2\", \"description\": \"ML (\"Meta Language\") is a general-purpose functional programming language. It has roots in Lisp, and has been characterized as \"Lisp with types\".\"} e.g. aliases.jsonl {\"alias\": \"ML\", \"entities\": [\"a1\", \"a2\"], \"probabilities\": [0.5, 0.5]} Options: --new-model-name TEXT --cg-threshold FLOAT --n-iter INTEGER --verbose / --no-verbose --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Now provide the required arguments. I'm using the example data but at this step use your own. the create_index command will run a few steps and you should see an output like the one below. spacy_ann create_index en_core_web_md examples/tutorial/data examples/tutorial/models // The create_index command runs a few steps // Load the model passed as the first positional argument (en_core_web_md) ===================== Load Model ====================== \u2839 Loading model en_core_web_md\u2714 Done. \u2139 0 entities without a description // Train an EntityEncoder on the descriptions of each Entity ================= Train EntityEncoder ================= \u2838 Starting training EntityEncoder\u2714 Done Training // Apply the EntityEncoder to get the final vectors for each entity ================= Apply EntityEncoder ================= \u2819 Applying EntityEncoder to descriptions\u2714 Finished, embeddings created \u2714 Done adding entities and aliases to kb // Create Nearest Neighbors index from the Aliases in kb_dir/aliases.jsonl ================== Create ANN Index =================== Fitting tfidf vectorizer on 6 aliases Fitting and saving vectorizer took 0.012949 seconds Finding empty (all zeros) tfidf vectors Deleting 2/6 aliases because their tfidf is empty Fitting ann index on 4 aliases 0% 10 20 30 40 50 60 70 80 90 100% |----|----|----|----|----|----|----|----|----|----| *************************************************** Fitting ann index took 0.030826 seconds License \u00b6 This project is licensed under the terms of the MIT license.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+ spaCy ANN Linker is convenient wrapper built on a few comprehensive, high-performing packages. spaCy nmslib (ANN Index) . nmslib (ANN Index) . scikit-learn (TF-IDF) . FastAPI (Web Service) .","title":"Requirements"},{"location":"#installation","text":"$ pip install spacy-ann-linker ---> 100% Successfully installed spacy-ann-linker","title":"Installation"},{"location":"#data-prerequisites","text":"To use this spaCy ANN Linker you need pre-existing Knowledge Base data. spaCy ANN Linker expects data to exist in 2 JSONL files together in a directory kb_dir \u2502 aliases.jsonl \u2502 entities.jsonl For testing the package, you can use the example data in examples/tutorial/data examples/tutorial/data \u2502 aliases.jsonl \u2502 entities.jsonl","title":"Data Prerequisites"},{"location":"#entitiesjsonl-record-format","text":"{ \"id\" : \"Canonical Entity Id\" , \"description\" : \"Entity Description used for Disambiguation\" } Example data { \"id\" : \"a1\" , \"description\" : \"Machine learning (ML) is the scientific study of algorithms and statistical models...\" } { \"id\" : \"a2\" , \"description\" : \"ML (\\\"Meta Language\\\") is a general-purpose functional programming language. It has roots in Lisp, and has been characterized as \\\"Lisp with types\\\".\" } { \"id\" : \"a3\" , \"description\" : \"Natural language processing (NLP) is a subfield of linguistics, computer science, information engineering, and artificial intelligence concerned with the interactions between computers and human (natural) languages, in particular how to program computers to process and analyze large amounts of natural language data.\" } { \"id\" : \"a4\" , \"description\" : \"Neuro-linguistic programming (NLP) is a pseudoscientific approach to communication, personal development, and psychotherapy created by Richard Bandler and John Grinder in California, United States in the 1970s.\" } ...","title":"entities.jsonl Record Format"},{"location":"#aliasesjsonl-record-format","text":"{ \"alias\" : \"alias string\" , \"entities\" : [ \"list\" , \"of\" , \"entity\" , \"ids\" ], \"probabilities\" : [ 0.5 , 0.5 ]} Example data { \"alias\" : \"ML\" , \"entities\" : [ \"a1\" , \"a2\" ], \"probabilities\" : [ 0.5 , 0.5 ]} { \"alias\" : \"Machine learning\" , \"entities\" : [ \"a1\" ], \"probabilities\" : [ 1.0 ]} { \"alias\" : \"Meta Language\" , \"entities\" : [ \"a2\" ], \"probabilities\" : [ 1.0 ]} { \"alias\" : \"NLP\" , \"entities\" : [ \"a3\" , \"a4\" ], \"probabilities\" : [ 0.5 , 0.5 ]} { \"alias\" : \"Natural language processing\" , \"entities\" : [ \"a3\" ], \"probabilities\" : [ 1.0 ]} { \"alias\" : \"Neuro-linguistic programming\" , \"entities\" : [ \"a4\" ], \"probabilities\" : [ 1.0 ]} ...","title":"aliases.jsonl Record Format"},{"location":"#spacy-prerequisites","text":"If you don't have a pretrained spaCy model, download one now. The model needs to have vectors so download a model bigger than en_core_web_sm $ spacy download en_core_web_md ---> 100% Successfully installed en_core_web_md","title":"spaCy prerequisites"},{"location":"#usage","text":"Once you have your data, and a spaCy model with vectors, compute the nearest neighbors index for your Aliases. Run the create_index help command to understand the required arguments. $ spacy_ann create_index --help spacy_ann create_index --help Usage: spacy_ann create_index [OPTIONS] MODEL KB_DIR OUTPUT_DIR Create an ApproxNearestNeighborsLinker based on the Character N-Gram TF- IDF vectors for aliases in a KnowledgeBase model (str): spaCy language model directory or name to load kb_dir (Path): path to the directory with kb entities.jsonl and aliases.jsonl files output_dir (Path): path to output_dir for spaCy model with ann_linker pipe kb File Formats e.g. entities.jsonl {\"id\": \"a1\", \"description\": \"Machine learning (ML) is the scientific study of algorithms and statistical models...\"} {\"id\": \"a2\", \"description\": \"ML (\"Meta Language\") is a general-purpose functional programming language. It has roots in Lisp, and has been characterized as \"Lisp with types\".\"} e.g. aliases.jsonl {\"alias\": \"ML\", \"entities\": [\"a1\", \"a2\"], \"probabilities\": [0.5, 0.5]} Options: --new-model-name TEXT --cg-threshold FLOAT --n-iter INTEGER --verbose / --no-verbose --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Now provide the required arguments. I'm using the example data but at this step use your own. the create_index command will run a few steps and you should see an output like the one below. spacy_ann create_index en_core_web_md examples/tutorial/data examples/tutorial/models // The create_index command runs a few steps // Load the model passed as the first positional argument (en_core_web_md) ===================== Load Model ====================== \u2839 Loading model en_core_web_md\u2714 Done. \u2139 0 entities without a description // Train an EntityEncoder on the descriptions of each Entity ================= Train EntityEncoder ================= \u2838 Starting training EntityEncoder\u2714 Done Training // Apply the EntityEncoder to get the final vectors for each entity ================= Apply EntityEncoder ================= \u2819 Applying EntityEncoder to descriptions\u2714 Finished, embeddings created \u2714 Done adding entities and aliases to kb // Create Nearest Neighbors index from the Aliases in kb_dir/aliases.jsonl ================== Create ANN Index =================== Fitting tfidf vectorizer on 6 aliases Fitting and saving vectorizer took 0.012949 seconds Finding empty (all zeros) tfidf vectors Deleting 2/6 aliases because their tfidf is empty Fitting ann index on 4 aliases 0% 10 20 30 40 50 60 70 80 90 100% |----|----|----|----|----|----|----|----|----|----| *************************************************** Fitting ann index took 0.030826 seconds","title":"Usage"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"alternatives/","text":"What inspired Typer , how it compares to other alternatives and what it learned from them. Coming soon...","title":"Alternatives, Inspiration and Comparisons"},{"location":"contributing/","text":"First, you might want to see the basic ways to help Typer and get help . Coming soon...","title":"Development - Contributing"},{"location":"features/","text":"Design based on FastAPI \u00b6 Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less. Just Modern Python \u00b6 It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro . You will also see a 20 seconds refresher on the section Tutorial - User Guide: First Steps . Editor support \u00b6 Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc. Short \u00b6 It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" . User friendly CLI apps \u00b6 The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work. The power of Click \u00b6 Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"Features"},{"location":"features/#design-based-on-fastapi","text":"Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less.","title":"Design based on FastAPI"},{"location":"features/#just-modern-python","text":"It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro . You will also see a 20 seconds refresher on the section Tutorial - User Guide: First Steps .","title":"Just Modern Python"},{"location":"features/#editor-support","text":"Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc.","title":"Editor support"},{"location":"features/#short","text":"It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" .","title":"Short"},{"location":"features/#user-friendly-cli-apps","text":"The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work.","title":"User friendly CLI apps"},{"location":"features/#the-power-of-click","text":"Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"The power of Click"},{"location":"help-typer/","text":"Are you liking Typer ? Would you like to help Typer, other users, and the author? Or would you like to get help with Typer ? There are very simple ways to help (several involve just one or two clicks). And there are several ways to get help too. Star Typer in GitHub \u00b6 You can \"star\" Typer in GitHub (clicking the star button at the top right): https://github.com/tiangolo/typer . By adding a star, other users will be able to find it more easily and see that it has been already useful for others. Watch the GitHub repository for releases \u00b6 You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . There you can select \"Releases only\". Doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of Typer with bug fixes and new features. Connect with the author \u00b6 You can connect with me (Sebasti\u00e1n Ram\u00edrez / tiangolo ) , the author. You can: Follow me on GitHub . See other Open Source projects I have created that could help you. Follow me to see when I create a new Open Source project. Follow me on Twitter . Tell me how you use Typer (I love to hear that). Ask questions. Connect with me on Linkedin . Talk to me. Endorse me or recommend me :) Read what I write (or follow me): Read other ideas, articles and tools I have created. Follow me to see when I publish something new. On Dev.to . On Medium . Tweet about Typer \u00b6 Tweet about Typer and let me and others know why you like it. Let me know how are you using Typer \u00b6 I love to hear about how Typer is being used, what have you liked in it, in which project/company you are using it, etc. You can let me know: On Twitter . On Linkedin . On Dev.to . On Medium . Help others with issues in GitHub \u00b6 You can see existing issues and try and help others. Watch the GitHub repository \u00b6 You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . If you select \"Watching\" instead of \"Releases only\", you will receive notifications when someone creates a new issue. Then you can try and help them solving those issues. Create issues \u00b6 You can create a new issue in the GitHub repository, for example to: Report a bug/issue. Suggest a new feature. Ask a question. Create a Pull Request \u00b6 You can create a Pull Request , for example: To fix a typo you found on the documentation. To propose new documentation sections. To fix an existing issue/bug. To add a new feature. Thanks!","title":"Help typer"},{"location":"help-typer/#star-typer-in-github","text":"You can \"star\" Typer in GitHub (clicking the star button at the top right): https://github.com/tiangolo/typer . By adding a star, other users will be able to find it more easily and see that it has been already useful for others.","title":"Star Typer in GitHub"},{"location":"help-typer/#watch-the-github-repository-for-releases","text":"You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . There you can select \"Releases only\". Doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of Typer with bug fixes and new features.","title":"Watch the GitHub repository for releases"},{"location":"help-typer/#connect-with-the-author","text":"You can connect with me (Sebasti\u00e1n Ram\u00edrez / tiangolo ) , the author. You can: Follow me on GitHub . See other Open Source projects I have created that could help you. Follow me to see when I create a new Open Source project. Follow me on Twitter . Tell me how you use Typer (I love to hear that). Ask questions. Connect with me on Linkedin . Talk to me. Endorse me or recommend me :) Read what I write (or follow me): Read other ideas, articles and tools I have created. Follow me to see when I publish something new. On Dev.to . On Medium .","title":"Connect with the author"},{"location":"help-typer/#tweet-about-typer","text":"Tweet about Typer and let me and others know why you like it.","title":"Tweet about Typer"},{"location":"help-typer/#let-me-know-how-are-you-using-typer","text":"I love to hear about how Typer is being used, what have you liked in it, in which project/company you are using it, etc. You can let me know: On Twitter . On Linkedin . On Dev.to . On Medium .","title":"Let me know how are you using Typer"},{"location":"help-typer/#help-others-with-issues-in-github","text":"You can see existing issues and try and help others.","title":"Help others with issues in GitHub"},{"location":"help-typer/#watch-the-github-repository","text":"You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . If you select \"Watching\" instead of \"Releases only\", you will receive notifications when someone creates a new issue. Then you can try and help them solving those issues.","title":"Watch the GitHub repository"},{"location":"help-typer/#create-issues","text":"You can create a new issue in the GitHub repository, for example to: Report a bug/issue. Suggest a new feature. Ask a question.","title":"Create issues"},{"location":"help-typer/#create-a-pull-request","text":"You can create a Pull Request , for example: To fix a typo you found on the documentation. To propose new documentation sections. To fix an existing issue/bug. To add a new feature. Thanks!","title":"Create a Pull Request"},{"location":"release-notes/","text":"Latest changes \u00b6 Update format for internal links. PR #38 . Tweak external links' format. PR #36 . 0.0.8 \u00b6 Update docs and add latest changes to MkDocs/website. PR #33 . Add extra tests for edge cases that don't belong in docs' examples. PR #32 . Add docs for CLI Parameters with Multiple Values . Includes tests for all the examples and bug fixes. PR #31 . Add docs for extra CLI parameter types: CLI Parameter Types: Number and CLI Parameter Types: Boolean CLI Options . PR #30 . Extend docs for Commands, add Commands: Typer Callback and Commands: One or Multiple . This includes tests for all the examples and bug fixes. PR #29 . Add docs for SubCommands - Command Groups . This includes tests for all the examples and bug fixes. PR #28 . Remove unneeded code for argument handling. PR #26 . Add docs for Launching Applications . PR #25 . Add docs for getting the CLI Application Directory . PR #24 . Add docs for Progress Bars . PR #23 . Add docs for Asking with Interactive Prompts . PR #22 . Update docs for path CLI option . PR #21 . Add colors module and docs for Printing and Colors and for Terminating , including tests. PR #20 . Refactor docs to make each individual page/section \"bite-sized\" / small. Add docs for CLI option names . Update typer.Argument() to remove invalid positional param_decls . PR #19 . 0.0.7 \u00b6 Add docs for CLI parameter types . Includes tests and file classes refactor. PR #17 . Add tests for completion. PR #15 and #16 . 0.0.6 \u00b6 Add docs for Commands . Includes a bug fix for handling default values set in typer.Typer() parameters. PR #14 . Add docs for CLI Arguments . PR #13 . Add docs for CLI Options . PR #12 . 0.0.5 \u00b6 Clean exports from Typer. Remove unneeded components from Click and add needed Exit exception. PR #11 . Fix and document extracting help from a function's docstring First Steps: Document your CLI app . PR #10 . Update references to --install-completion and --show-completion in docs. PR #9 . Fix testing utilities, add tests for First Steps examples. PR #8 . Add auto completion options by default when click-completion is installed: --install-completion and --show-completion . PR #7 . Update Termynal to have fixed sizes, add \"fast\" button, and use it in First Steps . PR #6 . Add custom automatic Termynal for docs. PR #5 . 0.0.4 \u00b6 Update short descriptions and assets. Docs rewording and fix typos. PR #1 by @mariacamilagl . 0.0.3 \u00b6 Fix group creation without name. 0.0.2 \u00b6 Add initial version of code, docs, etc. 0.0.1 \u00b6 First commit. Publish to PyPI to reserve package name.","title":"Release Notes"},{"location":"release-notes/#latest-changes","text":"Update format for internal links. PR #38 . Tweak external links' format. PR #36 .","title":"Latest changes"},{"location":"release-notes/#008","text":"Update docs and add latest changes to MkDocs/website. PR #33 . Add extra tests for edge cases that don't belong in docs' examples. PR #32 . Add docs for CLI Parameters with Multiple Values . Includes tests for all the examples and bug fixes. PR #31 . Add docs for extra CLI parameter types: CLI Parameter Types: Number and CLI Parameter Types: Boolean CLI Options . PR #30 . Extend docs for Commands, add Commands: Typer Callback and Commands: One or Multiple . This includes tests for all the examples and bug fixes. PR #29 . Add docs for SubCommands - Command Groups . This includes tests for all the examples and bug fixes. PR #28 . Remove unneeded code for argument handling. PR #26 . Add docs for Launching Applications . PR #25 . Add docs for getting the CLI Application Directory . PR #24 . Add docs for Progress Bars . PR #23 . Add docs for Asking with Interactive Prompts . PR #22 . Update docs for path CLI option . PR #21 . Add colors module and docs for Printing and Colors and for Terminating , including tests. PR #20 . Refactor docs to make each individual page/section \"bite-sized\" / small. Add docs for CLI option names . Update typer.Argument() to remove invalid positional param_decls . PR #19 .","title":"0.0.8"},{"location":"release-notes/#007","text":"Add docs for CLI parameter types . Includes tests and file classes refactor. PR #17 . Add tests for completion. PR #15 and #16 .","title":"0.0.7"},{"location":"release-notes/#006","text":"Add docs for Commands . Includes a bug fix for handling default values set in typer.Typer() parameters. PR #14 . Add docs for CLI Arguments . PR #13 . Add docs for CLI Options . PR #12 .","title":"0.0.6"},{"location":"release-notes/#005","text":"Clean exports from Typer. Remove unneeded components from Click and add needed Exit exception. PR #11 . Fix and document extracting help from a function's docstring First Steps: Document your CLI app . PR #10 . Update references to --install-completion and --show-completion in docs. PR #9 . Fix testing utilities, add tests for First Steps examples. PR #8 . Add auto completion options by default when click-completion is installed: --install-completion and --show-completion . PR #7 . Update Termynal to have fixed sizes, add \"fast\" button, and use it in First Steps . PR #6 . Add custom automatic Termynal for docs. PR #5 .","title":"0.0.5"},{"location":"release-notes/#004","text":"Update short descriptions and assets. Docs rewording and fix typos. PR #1 by @mariacamilagl .","title":"0.0.4"},{"location":"release-notes/#003","text":"Fix group creation without name.","title":"0.0.3"},{"location":"release-notes/#002","text":"Add initial version of code, docs, etc.","title":"0.0.2"},{"location":"release-notes/#001","text":"First commit. Publish to PyPI to reserve package name.","title":"0.0.1"},{"location":"tutorial/","text":"Python types \u00b6 If you need a refreshed about how to use Python type hints, check the first part of FastAPI's Python types intro . You can also check the mypy cheat sheet . In short (very short), you can declare a function with parameters like: def type_example ( name : str , formal : bool = False , intro : str = None ): pass And your editor (and Typer) will know that: name is of type str and is a required parameter. formal is a bool and is by default False . intro is a str , and by default is None , so it's optional. These type hints are what give you autocomplete in your editor and several other features. Typer is based on these type hints. Intro \u00b6 This tutorial shows you how to use Typer with all its features, step by step. Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific CLI needs. It is also built to work as a future reference. So you can come back and see exactly what you need. Run the code \u00b6 All the code blocks can be copied and used directly (they are tested Python files). To run any of the examples, copy the code to a file main.py , and run it: $ python main.py \u2728 The magic happens here \u2728 It is HIGHLY encouraged that you write or copy the code, edit it and run it locally. Using it in your editor is what really shows you the benefits of Typer, seeing how little code you have to write, all the type checks, autocompletion, etc. And running the examples is what will really help you understand what is going on. You can learn a lot more by running some examples and playing around with them than by reading all the docs here. Install Typer \u00b6 The first step is to install Typer. For the tutorial, you might want to install it with all the optional dependencies and features: $ pip install typer [ all ] ---> 100% Successfully installed typer click colorama click-completion ...that also includes colorama and click-completion .","title":"Tutorial - User Guide - Intro"},{"location":"tutorial/#python-types","text":"If you need a refreshed about how to use Python type hints, check the first part of FastAPI's Python types intro . You can also check the mypy cheat sheet . In short (very short), you can declare a function with parameters like: def type_example ( name : str , formal : bool = False , intro : str = None ): pass And your editor (and Typer) will know that: name is of type str and is a required parameter. formal is a bool and is by default False . intro is a str , and by default is None , so it's optional. These type hints are what give you autocomplete in your editor and several other features. Typer is based on these type hints.","title":"Python types"},{"location":"tutorial/#intro","text":"This tutorial shows you how to use Typer with all its features, step by step. Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific CLI needs. It is also built to work as a future reference. So you can come back and see exactly what you need.","title":"Intro"},{"location":"tutorial/#run-the-code","text":"All the code blocks can be copied and used directly (they are tested Python files). To run any of the examples, copy the code to a file main.py , and run it: $ python main.py \u2728 The magic happens here \u2728 It is HIGHLY encouraged that you write or copy the code, edit it and run it locally. Using it in your editor is what really shows you the benefits of Typer, seeing how little code you have to write, all the type checks, autocompletion, etc. And running the examples is what will really help you understand what is going on. You can learn a lot more by running some examples and playing around with them than by reading all the docs here.","title":"Run the code"},{"location":"tutorial/#install-typer","text":"The first step is to install Typer. For the tutorial, you might want to install it with all the optional dependencies and features: $ pip install typer [ all ] ---> 100% Successfully installed typer click colorama click-completion ...that also includes colorama and click-completion .","title":"Install Typer"},{"location":"tutorial/app-dir/","text":"You can get the application directory where you can, for example, save configuration files with typer.get_app_dir() : from pathlib import Path import typer APP_NAME = \"my-super-cli-app\" def main (): app_dir = typer . get_app_dir ( APP_NAME ) config_path : Path = Path ( app_dir ) / \"config.json\" if not config_path . is_file (): typer . echo ( \"Config file doesn't exist yet\" ) if __name__ == \"__main__\" : typer . run ( main ) It will give you a directory for storing configurations appropriate for your CLI program for the current user in each operating system. Check it: $ python main.py Config file doesn't exist yet About Path \u00b6 If you hadn't seen something like that: Path ( app_dir ) / \"config.json\" A Path object can be used with / and it will convert it to the separator for the current system ( / for Unix systems and \\ for Windows). If the first element is a Path object the next ones (after the / ) can be str . And it will create a new Path object from that. If you want a quick guide on using Path() you can check this post on Real Python or this post by Trey Hunner . In the code above, we are also explicitly declaring config_path as having type Path to help the editor provide completion and type checks: config_path : Path = Path ( app_dir ) / \"config.json\" Otherwise it could think it's a sub-type (a PurePath ) and stop providing completion for some methods.","title":"App dir"},{"location":"tutorial/app-dir/#about-path","text":"If you hadn't seen something like that: Path ( app_dir ) / \"config.json\" A Path object can be used with / and it will convert it to the separator for the current system ( / for Unix systems and \\ for Windows). If the first element is a Path object the next ones (after the / ) can be str . And it will create a new Path object from that. If you want a quick guide on using Path() you can check this post on Real Python or this post by Trey Hunner . In the code above, we are also explicitly declaring config_path as having type Path to help the editor provide completion and type checks: config_path : Path = Path ( app_dir ) / \"config.json\" Otherwise it could think it's a sub-type (a PurePath ) and stop providing completion for some methods.","title":"About Path"},{"location":"tutorial/arguments/","text":"Let's see how to configure CLI arguments with typer.Argument() . Optional CLI arguments \u00b6 We said before that by default : CLI options are optional CLI arguments are required Again, that's how they work by default , and that's the convention in many CLI programs and systems. But you can change that. In fact, it's very common to have optional CLI arguments , it's way more common than having required CLI options . As an example of how it could be useful, let's see how the ls CLI program works. // If you just type $ ls // ls will \"list\" the files and directories in the current directory typer tests README.md LICENSE // But it also receives an optional CLI argument $ ls ./tests/ // And then ls will list the files and directories inside of that directory from the CLI argument __init__.py test_tutorial An alternative CLI argument declaration \u00b6 In the First Steps you saw how to add a CLI argument : import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Now let's see an alternative way to create the same CLI argument : import typer def main ( name : str = typer . Argument ( ... )): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Before you had this function parameter: name : str And because name didn't have any default value it would be a required parameter for the Python function, in Python terms. Typer does the same and makes it a required CLI argument . And then we changed it to: name : str = typer . Argument ( ... ) But now as typer.Argument() is the \"default value\" of the function's parameter, it would mean that \"it is no longer required\" (in Python terms). As we no longer have the Python function default value (or its absence) to tell if something is required or not and what is the default value, the first parameter to typer.Argument() serves the same purpose of defining that default value, or making it required. To make it required , we pass ... as the first function argument passed to typer.Argument(...) . Info If you hadn't seen that ... before: it is a a special single value, it is part of Python and is called \"Ellipsis\" . All we did there achieves the same thing as before, a required CLI argument : $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". It's still not very useful, but it works correctly. And being able to declare a required CLI argument using name: str = typer.Argument(...) that works exactly the same as name: str will come handy later. Make an optional CLI argument \u00b6 Now, finally what we came for, an optional CLI argument . To make a CLI argument optional, use typer.Argument() and pass a different \"default\" as the first parameter to typer.Argument() , for example None : import typer def main ( name : str = typer . Argument ( None )): if name is None : typer . echo ( \"Hello World!\" ) else : typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Now we have: name : str = typer . Argument ( None ) Because we are using typer.Argument() Typer will know that this is a CLI argument (no matter if required or optional ). And because the first parameter passed to typer.Argument(None) (the new \"default\" value) is None , Typer knows that this is an optional CLI argument , if no value is provided when calling it in the command line, it will have that default value of None . Check the help: // First check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that NAME is still a CLI argument , it's shown up there in the \" Usage: main.py ...\". Also notice that now [NAME] has brackets (\" [ \" and \" ] \") around (before it was just NAME ) to denote that it's optional , not required . Now run it and test it: // With no CLI argument $ python main.py Hello World! // With one optional CLI argument $ python main.py Camila Hello Camila Tip Notice that \" Camila \" here is an optional CLI argument , not a CLI option , because we didn't use something like \" --name Camila \", we just passed \" Camila \" directly to the program. An optional CLI argument with a default \u00b6 We can also make a CLI argument have a default value other than None : import typer def main ( name : str = typer . Argument ( \"Wade Wilson\" )): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) And test it: // With no optional CLI argument $ python main.py Hello Wade Wilson // With one CLI argument $ python main.py Camila Hello Camila About CLI arguments help \u00b6 CLI arguments are commonly used for the most necessary things in a program. They are normally required and, when present, they are normally the main subject of whatever the command is doing. For that reason, Typer (actually Click underneath) doesn't attempt to automatically document CLI arguments . And you should document them as part of the CLI app documentation, normally in a docstring . Check the last example from the First Steps : import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) Here the CLI argument NAME is documented as part of the help text. You should document your CLI arguments the same way. Other uses \u00b6 typer.Argument() has several other users. For data validation, to enable other features, etc. But you will see about that later in the docs.","title":"Arguments"},{"location":"tutorial/arguments/#optional-cli-arguments","text":"We said before that by default : CLI options are optional CLI arguments are required Again, that's how they work by default , and that's the convention in many CLI programs and systems. But you can change that. In fact, it's very common to have optional CLI arguments , it's way more common than having required CLI options . As an example of how it could be useful, let's see how the ls CLI program works. // If you just type $ ls // ls will \"list\" the files and directories in the current directory typer tests README.md LICENSE // But it also receives an optional CLI argument $ ls ./tests/ // And then ls will list the files and directories inside of that directory from the CLI argument __init__.py test_tutorial","title":"Optional CLI arguments"},{"location":"tutorial/arguments/#an-alternative-cli-argument-declaration","text":"In the First Steps you saw how to add a CLI argument : import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Now let's see an alternative way to create the same CLI argument : import typer def main ( name : str = typer . Argument ( ... )): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Before you had this function parameter: name : str And because name didn't have any default value it would be a required parameter for the Python function, in Python terms. Typer does the same and makes it a required CLI argument . And then we changed it to: name : str = typer . Argument ( ... ) But now as typer.Argument() is the \"default value\" of the function's parameter, it would mean that \"it is no longer required\" (in Python terms). As we no longer have the Python function default value (or its absence) to tell if something is required or not and what is the default value, the first parameter to typer.Argument() serves the same purpose of defining that default value, or making it required. To make it required , we pass ... as the first function argument passed to typer.Argument(...) . Info If you hadn't seen that ... before: it is a a special single value, it is part of Python and is called \"Ellipsis\" . All we did there achieves the same thing as before, a required CLI argument : $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". It's still not very useful, but it works correctly. And being able to declare a required CLI argument using name: str = typer.Argument(...) that works exactly the same as name: str will come handy later.","title":"An alternative CLI argument declaration"},{"location":"tutorial/arguments/#make-an-optional-cli-argument","text":"Now, finally what we came for, an optional CLI argument . To make a CLI argument optional, use typer.Argument() and pass a different \"default\" as the first parameter to typer.Argument() , for example None : import typer def main ( name : str = typer . Argument ( None )): if name is None : typer . echo ( \"Hello World!\" ) else : typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Now we have: name : str = typer . Argument ( None ) Because we are using typer.Argument() Typer will know that this is a CLI argument (no matter if required or optional ). And because the first parameter passed to typer.Argument(None) (the new \"default\" value) is None , Typer knows that this is an optional CLI argument , if no value is provided when calling it in the command line, it will have that default value of None . Check the help: // First check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that NAME is still a CLI argument , it's shown up there in the \" Usage: main.py ...\". Also notice that now [NAME] has brackets (\" [ \" and \" ] \") around (before it was just NAME ) to denote that it's optional , not required . Now run it and test it: // With no CLI argument $ python main.py Hello World! // With one optional CLI argument $ python main.py Camila Hello Camila Tip Notice that \" Camila \" here is an optional CLI argument , not a CLI option , because we didn't use something like \" --name Camila \", we just passed \" Camila \" directly to the program.","title":"Make an optional CLI argument"},{"location":"tutorial/arguments/#an-optional-cli-argument-with-a-default","text":"We can also make a CLI argument have a default value other than None : import typer def main ( name : str = typer . Argument ( \"Wade Wilson\" )): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) And test it: // With no optional CLI argument $ python main.py Hello Wade Wilson // With one CLI argument $ python main.py Camila Hello Camila","title":"An optional CLI argument with a default"},{"location":"tutorial/arguments/#about-cli-arguments-help","text":"CLI arguments are commonly used for the most necessary things in a program. They are normally required and, when present, they are normally the main subject of whatever the command is doing. For that reason, Typer (actually Click underneath) doesn't attempt to automatically document CLI arguments . And you should document them as part of the CLI app documentation, normally in a docstring . Check the last example from the First Steps : import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) Here the CLI argument NAME is documented as part of the help text. You should document your CLI arguments the same way.","title":"About CLI arguments help"},{"location":"tutorial/arguments/#other-uses","text":"typer.Argument() has several other users. For data validation, to enable other features, etc. But you will see about that later in the docs.","title":"Other uses"},{"location":"tutorial/first-steps/","text":"The simplest example \u00b6 The simplest Typer file could look like this: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip You will learn more about typer.echo() later in the docs. Copy that to a file main.py . Test it: $ python main.py Hello World // It just prints \"Hello World\". // Now check the --help $ python main.py --help Usage: main.py [OPTIONS] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. ...but this program is still not very useful. Let's extend it. What is a CLI argument \u00b6 Here we will use the word CLI argument to refer to CLI parameters passed in some specific order to the CLI application. By default, they are required . If you go to your terminal and type: $ ls ./myproject first-steps.md intro.md ls will show the contents of the directory ./myproject . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument , in this case it refers to the path of a directory. They are a bit different from CLI options that you will see later below. Add a CLI argument \u00b6 Update the previous example with an argument name : import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py // If you run it without the argument, it shows a nice error Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". // Now pass that NAME CLI argument $ python main.py Camila Hello Camila // Here \"Camila\" is the CLI argument // To pass a name with spaces for the same CLI argument, use quotes $ python main.py \"Camila Guti\u00e9rrez\" Hello Camila Guti\u00e9rrez Tip If you need to pass a single value that contains spaces to a CLI argument , use quotes ( \" ) around it. Two CLI arguments \u00b6 Now let's say we want to have the name and last name separated. So, extend that to have 2 arguments, name and lastname : import typer def main ( name : str , lastname : str ): typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) // Check the main --help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Options: --help Show this message and exit. // There are now 2 CLI arguments, name and lastname // Now pass a single name argument $ python main.py Camila Usage: main.py [OPTIONS] NAME LASTNAME Try \"main.py --help\" for help. Error: Missing argument \"LASTNAME\". // These 2 arguments are required, so, pass both: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that the order is important. The last name has to go after the first name. If you called it with: $ python main.py Guti\u00e9rrez Camila your app wouldn't have a way to know which is the name and which the lastname . It expects the first CLI argument to be the name and the second CLI argument to be the lastname . What is a CLI option \u00b6 Here we will use the word CLI option to refer to CLI parameters passed to the CLI application with a specific name. For example, if you go to your terminal and type: $ ls ./myproject --size 12 first-steps.md 4 intro.md ls will show the contents of the directory ./myproject with their size . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument . --size is an optional CLI option . The program knows it has to show the size because it sees --size , not because of the order. A CLI option like --size doesn't depend on the order like a CLI argument . So, if you put the --size before the CLI argument , it still works: $ ls --size ./myproject 12 first-steps.md 4 intro.md The main visual difference between a CLI option and and a CLI argument is that the CLI option has -- prepended to the name, like in \" --size \". A CLI option doesn't depend on the order because it has a predefined name (here it's --size ). This is because the CLI app is looking specifically for a literal --size parameter (also known as \"flag\" or \"switch\"), with that specific \"name\" (here the specific name is \" --size \"). The CLI app will check if you typed it or not, it will be actively looking for --size even if you didn't type it (to check if it's there or not). In contrast, the CLI app is not actively looking for the CLI argument with a text \" ./myproject \", it has no way to know if you would type ./myproject or ./my-super-awesome-project or anything else. It's just waiting to get whatever you give it. The only way to know that you refer to a specific CLI argument is because of the order. The same way that it knows that the first CLI argument was the name and the second was the lastname , but if you mixed the order, it wouldn't be able to handle it. Instead, with a CLI option , the order doesn't matter. Also, by default, a CLI option is optional (not required ). So, by default: A CLI argument is required A CLI option is optional But the required and optional defaults can be changed. So, the main and most important difference is that: CLI options start with -- and don't depend on the order CLI arguments depend on the sequence order Tip In this example above the CLI option --size is just a \"flag\" or \"switch\" that will contain a boolean value, True or False , depending on if it was added to the command or not. This one doesn't receive any values. But CLI options can also receive values like CLI arguments . You'll see how later. Add one CLI option \u00b6 Now add a --formal CLI option : import typer def main ( name : str , lastname : str , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) Here formal is a bool that is False by default. // Get the help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Options: --formal / --no-formal --help Show this message and exit. Tip Notice that it automatically creates a --formal and a --no-formal because it detected that formal is a bool . Now call it normally: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez // But if you pass --formal $ python main.py Camila Guti\u00e9rrez --formal Good day Ms. Camila Guti\u00e9rrez. // And as --formal is a CLI option you can put it anywhere in this command $ python main.py Camila --formal Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez. $ python main.py --formal Camila Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez. A CLI option with a value \u00b6 To convert the lastname from a CLI argument to a CLI option , give it a default value of \"\" : import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) As lastname now has a default value of \"\" (an empty string) it is no longer required in the function, and Typer will now by default make it an optional CLI option . $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --lastname TEXT --formal / --no-formal --help Show this message and exit. Tip Notice the --lastname , and notice that it takes a textual value. A CLI option with a value like --lastname (contrary to a CLI option without a value, a bool flag, like --formal or --size ) takes as its value whatever is at the right side of the CLI option . // Call it without a --lastname $ python main.py Camila Hello Camila // Pass the --lastname $ python main.py Camila --lastname Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that \" Guti\u00e9rrez \" is at the right side of --lastname . A CLI option with a value takes as its value whatever is at the right side . And as --lastname is now a CLI option that doesn't depend on the order, you can pass it before the name: $ python main.py --lastname Guti\u00e9rrez Camila // and it will still work normally Hello Camila Guti\u00e9rrez Document your CLI app \u00b6 If you add a docstring to your function it will be used in the help text: import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) Now see it with the --help option: $ python main.py --help Usage: main.py [OPTIONS] NAME Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. Options: --lastname TEXT --formal / --no-formal --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip You should document the CLI arguments in the docstring. There is another place to document the CLI options that will show up next to them in the help text as with --install-completion or --help , you will learn that later in the tutorial. But CLI arguments are normally used for the most necessary things, so you should document them here in the docstring . Arguments, options, parameters, optional, required \u00b6 Be aware that these terms refer to multiple things depending on the context, and sadly, those \"contexts\" mix frequently, so it's easy to get confused. In Python \u00b6 In Python, the names of the variables in a function, like name and lastname : def main ( name : str , lastname : str = \"\" ): pass are called \"Python function parameters\" or \"Python function arguments\". Technical Details There's actually a very small distinction in Python between \"parameter\" and \"argument\". It's quite technical... and somewhat pedantic. One refers to the variable name in a function declaration . Like: def bring_person(name: str, lastname: str = \"\"): pass The other refers to the value passed when calling a function. Like: person = bring_person(\"Camila\", lastname=\"Guti\u00e9rrez\") ...but you will probably see them used interchangeably in most of the places (including here). Python default values \u00b6 In Python, in a function, a parameter with a default value like lastname in: def main ( name : str , lastname : str = \"\" ): pass is considered an \"optional parameter\" (or \"optional argument\"). The default value can be anything, like \"\" or None . And a parameter like name , that doesn't have a default value, is considered required . In CLIs \u00b6 When talking about command line interfaces/applications, the words \"argument\" and \"parameter\" are commonly used to refer to that data passed to a CLI app, those parameters. But those words don't imply anything about the data being required, needing to be passed in a certain order, nor having a flag like --lastname . The parameters that come with a name like --lastname (and optionally a value) are commonly optional, not required. So, when talking about CLIs it's common to call them optional arguments or optional parameters . Sometimes these optional parameters that start with -- are also called a flag or a switch . In reality, the parameters that require an order can be made optional too. And the ones that come with a flag (like --lastname ) can be required too. In Typer \u00b6 To try and make it a bit easier, we'll normally use the words \"parameter\" or \"argument\" to refer to Python functions. We'll use CLI argument to refer to those CLI parameters that depend on an order. That are required by default. And we'll use CLI option to refer to those CLI parameters that depend on a name that starts with -- (like --lastname ). That are optional by default. We will use CLI parameter to refer to both, CLI arguments and CLI options .","title":"First Steps"},{"location":"tutorial/first-steps/#the-simplest-example","text":"The simplest Typer file could look like this: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip You will learn more about typer.echo() later in the docs. Copy that to a file main.py . Test it: $ python main.py Hello World // It just prints \"Hello World\". // Now check the --help $ python main.py --help Usage: main.py [OPTIONS] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. ...but this program is still not very useful. Let's extend it.","title":"The simplest example"},{"location":"tutorial/first-steps/#what-is-a-cli-argument","text":"Here we will use the word CLI argument to refer to CLI parameters passed in some specific order to the CLI application. By default, they are required . If you go to your terminal and type: $ ls ./myproject first-steps.md intro.md ls will show the contents of the directory ./myproject . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument , in this case it refers to the path of a directory. They are a bit different from CLI options that you will see later below.","title":"What is a CLI argument"},{"location":"tutorial/first-steps/#add-a-cli-argument","text":"Update the previous example with an argument name : import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py // If you run it without the argument, it shows a nice error Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". // Now pass that NAME CLI argument $ python main.py Camila Hello Camila // Here \"Camila\" is the CLI argument // To pass a name with spaces for the same CLI argument, use quotes $ python main.py \"Camila Guti\u00e9rrez\" Hello Camila Guti\u00e9rrez Tip If you need to pass a single value that contains spaces to a CLI argument , use quotes ( \" ) around it.","title":"Add a CLI argument"},{"location":"tutorial/first-steps/#two-cli-arguments","text":"Now let's say we want to have the name and last name separated. So, extend that to have 2 arguments, name and lastname : import typer def main ( name : str , lastname : str ): typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) // Check the main --help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Options: --help Show this message and exit. // There are now 2 CLI arguments, name and lastname // Now pass a single name argument $ python main.py Camila Usage: main.py [OPTIONS] NAME LASTNAME Try \"main.py --help\" for help. Error: Missing argument \"LASTNAME\". // These 2 arguments are required, so, pass both: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that the order is important. The last name has to go after the first name. If you called it with: $ python main.py Guti\u00e9rrez Camila your app wouldn't have a way to know which is the name and which the lastname . It expects the first CLI argument to be the name and the second CLI argument to be the lastname .","title":"Two CLI arguments"},{"location":"tutorial/first-steps/#what-is-a-cli-option","text":"Here we will use the word CLI option to refer to CLI parameters passed to the CLI application with a specific name. For example, if you go to your terminal and type: $ ls ./myproject --size 12 first-steps.md 4 intro.md ls will show the contents of the directory ./myproject with their size . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument . --size is an optional CLI option . The program knows it has to show the size because it sees --size , not because of the order. A CLI option like --size doesn't depend on the order like a CLI argument . So, if you put the --size before the CLI argument , it still works: $ ls --size ./myproject 12 first-steps.md 4 intro.md The main visual difference between a CLI option and and a CLI argument is that the CLI option has -- prepended to the name, like in \" --size \". A CLI option doesn't depend on the order because it has a predefined name (here it's --size ). This is because the CLI app is looking specifically for a literal --size parameter (also known as \"flag\" or \"switch\"), with that specific \"name\" (here the specific name is \" --size \"). The CLI app will check if you typed it or not, it will be actively looking for --size even if you didn't type it (to check if it's there or not). In contrast, the CLI app is not actively looking for the CLI argument with a text \" ./myproject \", it has no way to know if you would type ./myproject or ./my-super-awesome-project or anything else. It's just waiting to get whatever you give it. The only way to know that you refer to a specific CLI argument is because of the order. The same way that it knows that the first CLI argument was the name and the second was the lastname , but if you mixed the order, it wouldn't be able to handle it. Instead, with a CLI option , the order doesn't matter. Also, by default, a CLI option is optional (not required ). So, by default: A CLI argument is required A CLI option is optional But the required and optional defaults can be changed. So, the main and most important difference is that: CLI options start with -- and don't depend on the order CLI arguments depend on the sequence order Tip In this example above the CLI option --size is just a \"flag\" or \"switch\" that will contain a boolean value, True or False , depending on if it was added to the command or not. This one doesn't receive any values. But CLI options can also receive values like CLI arguments . You'll see how later.","title":"What is a CLI option"},{"location":"tutorial/first-steps/#add-one-cli-option","text":"Now add a --formal CLI option : import typer def main ( name : str , lastname : str , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) Here formal is a bool that is False by default. // Get the help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Options: --formal / --no-formal --help Show this message and exit. Tip Notice that it automatically creates a --formal and a --no-formal because it detected that formal is a bool . Now call it normally: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez // But if you pass --formal $ python main.py Camila Guti\u00e9rrez --formal Good day Ms. Camila Guti\u00e9rrez. // And as --formal is a CLI option you can put it anywhere in this command $ python main.py Camila --formal Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez. $ python main.py --formal Camila Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez.","title":"Add one CLI option"},{"location":"tutorial/first-steps/#a-cli-option-with-a-value","text":"To convert the lastname from a CLI argument to a CLI option , give it a default value of \"\" : import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) As lastname now has a default value of \"\" (an empty string) it is no longer required in the function, and Typer will now by default make it an optional CLI option . $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --lastname TEXT --formal / --no-formal --help Show this message and exit. Tip Notice the --lastname , and notice that it takes a textual value. A CLI option with a value like --lastname (contrary to a CLI option without a value, a bool flag, like --formal or --size ) takes as its value whatever is at the right side of the CLI option . // Call it without a --lastname $ python main.py Camila Hello Camila // Pass the --lastname $ python main.py Camila --lastname Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that \" Guti\u00e9rrez \" is at the right side of --lastname . A CLI option with a value takes as its value whatever is at the right side . And as --lastname is now a CLI option that doesn't depend on the order, you can pass it before the name: $ python main.py --lastname Guti\u00e9rrez Camila // and it will still work normally Hello Camila Guti\u00e9rrez","title":"A CLI option with a value"},{"location":"tutorial/first-steps/#document-your-cli-app","text":"If you add a docstring to your function it will be used in the help text: import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) Now see it with the --help option: $ python main.py --help Usage: main.py [OPTIONS] NAME Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. Options: --lastname TEXT --formal / --no-formal --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip You should document the CLI arguments in the docstring. There is another place to document the CLI options that will show up next to them in the help text as with --install-completion or --help , you will learn that later in the tutorial. But CLI arguments are normally used for the most necessary things, so you should document them here in the docstring .","title":"Document your CLI app"},{"location":"tutorial/first-steps/#arguments-options-parameters-optional-required","text":"Be aware that these terms refer to multiple things depending on the context, and sadly, those \"contexts\" mix frequently, so it's easy to get confused.","title":"Arguments, options, parameters, optional, required"},{"location":"tutorial/first-steps/#in-python","text":"In Python, the names of the variables in a function, like name and lastname : def main ( name : str , lastname : str = \"\" ): pass are called \"Python function parameters\" or \"Python function arguments\". Technical Details There's actually a very small distinction in Python between \"parameter\" and \"argument\". It's quite technical... and somewhat pedantic. One refers to the variable name in a function declaration . Like: def bring_person(name: str, lastname: str = \"\"): pass The other refers to the value passed when calling a function. Like: person = bring_person(\"Camila\", lastname=\"Guti\u00e9rrez\") ...but you will probably see them used interchangeably in most of the places (including here).","title":"In Python"},{"location":"tutorial/first-steps/#python-default-values","text":"In Python, in a function, a parameter with a default value like lastname in: def main ( name : str , lastname : str = \"\" ): pass is considered an \"optional parameter\" (or \"optional argument\"). The default value can be anything, like \"\" or None . And a parameter like name , that doesn't have a default value, is considered required .","title":"Python default values"},{"location":"tutorial/first-steps/#in-clis","text":"When talking about command line interfaces/applications, the words \"argument\" and \"parameter\" are commonly used to refer to that data passed to a CLI app, those parameters. But those words don't imply anything about the data being required, needing to be passed in a certain order, nor having a flag like --lastname . The parameters that come with a name like --lastname (and optionally a value) are commonly optional, not required. So, when talking about CLIs it's common to call them optional arguments or optional parameters . Sometimes these optional parameters that start with -- are also called a flag or a switch . In reality, the parameters that require an order can be made optional too. And the ones that come with a flag (like --lastname ) can be required too.","title":"In CLIs"},{"location":"tutorial/first-steps/#in-typer","text":"To try and make it a bit easier, we'll normally use the words \"parameter\" or \"argument\" to refer to Python functions. We'll use CLI argument to refer to those CLI parameters that depend on an order. That are required by default. And we'll use CLI option to refer to those CLI parameters that depend on a name that starts with -- (like --lastname ). That are optional by default. We will use CLI parameter to refer to both, CLI arguments and CLI options .","title":"In Typer"},{"location":"tutorial/launch/","text":"You can launch applications from your CLI program with typer.launch() . It will launch the appropriate application depending on the URL or file type you pass it: import typer def main (): typer . echo ( \"Opening Typer's docs\" ) typer . launch ( \"https://typer.tiangolo.com\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Opening Typer docs // Opens browser with Typer's docs Locating a file \u00b6 You can also make the operating system open the file browser indicating where a file is located with locate=True : from pathlib import Path import typer APP_NAME = \"my-super-cli-app\" def main (): app_dir = typer . get_app_dir ( APP_NAME ) app_dir_path = Path ( app_dir ) app_dir_path . mkdir ( parents = True , exist_ok = True ) config_path : Path = Path ( app_dir ) / \"config.json\" if not config_path . is_file (): config_path . write_text ( '{\"version\": \"1.0.0\"}' ) config_file_str = str ( config_path ) typer . echo ( \"Opening config directory\" ) typer . launch ( config_file_str , locate = True ) if __name__ == \"__main__\" : typer . run ( main ) Tip The rest of the code in this example is just making sure the app directory exists and creating the config file. But the most important part is the typer.launch(config_file_str, locate=True) with the argument locate=True . Check it: $ python main.py Opening config directory // Opens a file browser indicating where the config file is located","title":"Launch"},{"location":"tutorial/launch/#locating-a-file","text":"You can also make the operating system open the file browser indicating where a file is located with locate=True : from pathlib import Path import typer APP_NAME = \"my-super-cli-app\" def main (): app_dir = typer . get_app_dir ( APP_NAME ) app_dir_path = Path ( app_dir ) app_dir_path . mkdir ( parents = True , exist_ok = True ) config_path : Path = Path ( app_dir ) / \"config.json\" if not config_path . is_file (): config_path . write_text ( '{\"version\": \"1.0.0\"}' ) config_file_str = str ( config_path ) typer . echo ( \"Opening config directory\" ) typer . launch ( config_file_str , locate = True ) if __name__ == \"__main__\" : typer . run ( main ) Tip The rest of the code in this example is just making sure the app directory exists and creating the config file. But the most important part is the typer.launch(config_file_str, locate=True) with the argument locate=True . Check it: $ python main.py Opening config directory // Opens a file browser indicating where the config file is located","title":"Locating a file"},{"location":"tutorial/printing/","text":"You can use typer.echo() to print to the screen: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) The reason to use typer.echo() instead of just print() is that it applies some error corrections in case the terminal is misconfigured, and it will properly output color if it's supported. Info typer.echo() comes directly from Click, you can read more about it in Click's docs . Check it: $ python main.py Hello World Color \u00b6 Info For colors to work correctly on Windows you need to also install colorama . You don't need to call colorama.init() . Typer (actually Click) will handle it underneath. Technical Details The way color works in terminals is by using some codes (ASCII codes) as part of the text. So, a colored text is still just a str . You can create colored strings to output to the terminal with typer.style() , that gives you str s that you can then pass to typer.echo() : import typer def main ( good : bool = True ): message_start = \"everything is \" if good : ending = typer . style ( \"good\" , fg = typer . colors . GREEN , bold = True ) else : ending = typer . style ( \"bad\" , fg = typer . colors . WHITE , bg = typer . colors . RED ) message = message_start + ending typer . echo ( message ) if __name__ == \"__main__\" : typer . run ( main ) Tip The parameters fg and bg receive strings with the color names. You could simply pass fg=\"green\" and bg=\"red\" . But Typer provides them all as variables like typer.colors.GREEN just so you can use autocompletion while selecting them. Check it: python main.py everything is good python main.py --no-good everything is bad You can pass these function arguments to typer.style() : fg : the foreground color. bg : the background color. bold : enable or disable bold mode. dim : enable or disable dim mode. This is badly supported. underline : enable or disable underline. blink : enable or disable blinking. reverse : enable or disable inverse rendering (foreground becomes background and the other way round). reset : by default a reset-all code is added at the end of the string which means that styles do not carry over. This can be disabled to compose styles. Info You can read more about it in Click's docs about style() typer.secho() - style and print \u00b6 There's a shorter form to style and print at the same time with typer.secho() it's like typer.echo() but also adds style like typer.style() : import typer def main ( name : str ): typer . secho ( f \"Welcome here {name} \" , fg = typer . colors . MAGENTA ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Camila Welcome here Camila","title":"CLI"},{"location":"tutorial/printing/#color","text":"Info For colors to work correctly on Windows you need to also install colorama . You don't need to call colorama.init() . Typer (actually Click) will handle it underneath. Technical Details The way color works in terminals is by using some codes (ASCII codes) as part of the text. So, a colored text is still just a str . You can create colored strings to output to the terminal with typer.style() , that gives you str s that you can then pass to typer.echo() : import typer def main ( good : bool = True ): message_start = \"everything is \" if good : ending = typer . style ( \"good\" , fg = typer . colors . GREEN , bold = True ) else : ending = typer . style ( \"bad\" , fg = typer . colors . WHITE , bg = typer . colors . RED ) message = message_start + ending typer . echo ( message ) if __name__ == \"__main__\" : typer . run ( main ) Tip The parameters fg and bg receive strings with the color names. You could simply pass fg=\"green\" and bg=\"red\" . But Typer provides them all as variables like typer.colors.GREEN just so you can use autocompletion while selecting them. Check it: python main.py everything is good python main.py --no-good everything is bad You can pass these function arguments to typer.style() : fg : the foreground color. bg : the background color. bold : enable or disable bold mode. dim : enable or disable dim mode. This is badly supported. underline : enable or disable underline. blink : enable or disable blinking. reverse : enable or disable inverse rendering (foreground becomes background and the other way round). reset : by default a reset-all code is added at the end of the string which means that styles do not carry over. This can be disabled to compose styles. Info You can read more about it in Click's docs about style()","title":"Color"},{"location":"tutorial/printing/#typersecho-style-and-print","text":"There's a shorter form to style and print at the same time with typer.secho() it's like typer.echo() but also adds style like typer.style() : import typer def main ( name : str ): typer . secho ( f \"Welcome here {name} \" , fg = typer . colors . MAGENTA ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Camila Welcome here Camila","title":"typer.secho() - style and print"},{"location":"tutorial/progressbar/","text":"If you are executing an operation that can take some time, you can inform it to the user with a progress bar. For this, you can use typer.progressbar() : import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 )) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed {total} things.\" ) if __name__ == \"__main__\" : typer . run ( main ) You use typer.progressbar() with a with statement, as in: with typer . progressbar ( something ) as progress : pass And you pass as function argument to typer.progressbar() the thing that you would normally iterate over. So, if you have a list of users, this could be: users = [ \"Camila\" , \"Rick\" , \"Morty\" ] with typer . progressbar ( users ) as progress : pass And the with statement using typer.progressbar() gives you an object that you can iterate over, just like if it was the same thing that you would iterate over normally. But by iterating over this object Typer (actually Click) will know to update the progress bar: users = [ \"Camila\" , \"Rick\" , \"Morty\" ] with typer . progressbar ( users ) as progress : for user in progress : typer . echo ( user ) Tip Notice that there are 2 levels of code blocks. One for the with statement and one for the for statement. Info This is mostly useful for operations that take some time. In the example above we are faking it with time.sleep() . Check it: $ python main.py ---> 100% Processed 100 things. Setting a Progress Bar length \u00b6 The progress bar is generated from the length of the iterable (e.g. the list of users). But if the length is not available (for example, with something that fetches a new user from a web API each time) you can pass an explicit length to typer.progressbar() . import time import typer def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i def main (): total = 0 with typer . progressbar ( iterate_user_ids (), length = 100 ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed {total} user IDs.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py ---> 100% Processed 100 user IDs. About the function with yield \u00b6 If you hadn't seen something like that yield above, that's a \" generator \". You can iterate over that function with a for and at each iteration it will give you the value at yield . yield is like a return that gives values multiple times and let's you use the function in a for loop. For example: def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i for i in iterate_user_ids (): print ( i ) would print each of the \"user IDs\" (here it's just the numbers from 0 to 99 ). Add a label \u00b6 You can also set a label : import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 ), label = \"Processing\" ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed {total} things.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things. Iterate manually \u00b6 If you need to manually iterate over something and update the progress bar irregularly, you can do it by not passing an iterable but just a length to typer.progressbar() . And then calling the .update() method in the object from the with statement: import time import typer def main (): total = 1000 with typer . progressbar ( length = total ) as progress : for batch in range ( 4 ): # Fake processing time time . sleep ( 1 ) progress . update ( 2500 ) typer . echo ( f \"Processed {total} things in batches.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things in batches.","title":"Progressbar"},{"location":"tutorial/progressbar/#setting-a-progress-bar-length","text":"The progress bar is generated from the length of the iterable (e.g. the list of users). But if the length is not available (for example, with something that fetches a new user from a web API each time) you can pass an explicit length to typer.progressbar() . import time import typer def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i def main (): total = 0 with typer . progressbar ( iterate_user_ids (), length = 100 ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed {total} user IDs.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py ---> 100% Processed 100 user IDs.","title":"Setting a Progress Bar length"},{"location":"tutorial/progressbar/#about-the-function-with-yield","text":"If you hadn't seen something like that yield above, that's a \" generator \". You can iterate over that function with a for and at each iteration it will give you the value at yield . yield is like a return that gives values multiple times and let's you use the function in a for loop. For example: def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i for i in iterate_user_ids (): print ( i ) would print each of the \"user IDs\" (here it's just the numbers from 0 to 99 ).","title":"About the function with yield"},{"location":"tutorial/progressbar/#add-a-label","text":"You can also set a label : import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 ), label = \"Processing\" ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed {total} things.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things.","title":"Add a label"},{"location":"tutorial/progressbar/#iterate-manually","text":"If you need to manually iterate over something and update the progress bar irregularly, you can do it by not passing an iterable but just a length to typer.progressbar() . And then calling the .update() method in the object from the with statement: import time import typer def main (): total = 1000 with typer . progressbar ( length = total ) as progress : for batch in range ( 4 ): # Fake processing time time . sleep ( 1 ) progress . update ( 2500 ) typer . echo ( f \"Processed {total} things in batches.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things in batches.","title":"Iterate manually"},{"location":"tutorial/prompt/","text":"When you need to ask the user for info interactively you should normally use CLI Option s with Prompt , because they allow using the CLI program in a non-interactive way (for example, a Bash script could use it). But if you absolutely need to ask for interactive information without using a CLI option , you can use typer.prompt() : import typer def main (): person_name = typer . prompt ( \"What's your name?\" ) typer . echo ( f \"Hello {person_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py # What ' s your name?:$ Camila Hello Camila Confirm \u00b6 There's also an alternative to ask for confirmation. Again, if possible, you should use a CLI Option with a confirmation prompt : import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" ) if not delete : typer . echo ( \"Not deleting\" ) raise typer . Abort () typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Not deleting Aborted! Confirm or abort \u00b6 As it's very common to abort if the user doesn't confirm, there's an integrated parameter abort that does it automatically: import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" , abort = True ) typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Aborted!","title":"Prompt"},{"location":"tutorial/prompt/#confirm","text":"There's also an alternative to ask for confirmation. Again, if possible, you should use a CLI Option with a confirmation prompt : import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" ) if not delete : typer . echo ( \"Not deleting\" ) raise typer . Abort () typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Not deleting Aborted!","title":"Confirm"},{"location":"tutorial/prompt/#confirm-or-abort","text":"As it's very common to abort if the user doesn't confirm, there's an integrated parameter abort that does it automatically: import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" , abort = True ) typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Aborted!","title":"Confirm or abort"},{"location":"tutorial/terminating/","text":"There are some cases where you might want to terminate a command at some point, and stop all subsequent execution. It could be that your code determined that the program completed successfully, or it could be an operation aborted. Exit a CLI program \u00b6 You can normally just let the code of your CLI program finish its execution, but in some scenarios, you might want to terminate at some point in the middle of it. And prevent any subsequent code to run. This doesn't have to mean that there's an error, just that nothing else needs to be executed. In that case, you can raise a typer.Exit() exception: import typer existing_usernames = [ \"rick\" , \"morty\" ] def maybe_create_user ( username : str ): if username in existing_usernames : typer . echo ( \"The user already exists\" ) raise typer . Exit () else : typer . echo ( f \"User created: {username} \" ) def send_new_user_notification ( username : str ): # Somehow send a notification here for the new user, maybe an email typer . echo ( f \"Notification sent for new user: {username} \" ) def main ( username : str ): maybe_create_user ( username = username ) send_new_user_notification ( username = username ) if __name__ == \"__main__\" : typer . run ( main ) There are several things to see in this example. The CLI program is the function main() , not the others. This is the one that takes a CLI argument . The function maybe_create_user() can terminate the program by raising typer.Exit() . If the program is terminated by maybe_create_user() then send_new_user_notification() will never execute inside of main() . Check it: $ python main.py Camila User created: Camila Notification sent for new user: Camila // Try with an existing user $ python main.py rick The user already exists // Notice that the notification code was never run, the second message is not printed Tip Even though you are rasing an exception, it doesn't necessarily mean there's an error. This is done with an exception because it works as an \"error\" and stops all execution. But then Typer (actually Click) catches it and just terminates the program normally. Exit with an error \u00b6 typer.Exit() takes an optional code parameter. By default, code is 0 , meaning there was no error. You can pass a code with a number other than 0 to tell the terminal that there was an error in the execution of the program: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Exit ( code = 1 ) typer . echo ( f \"New user created: {username} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Print the result code of the last program executed $ echo $? 0 // Now make it exit with an error $ python main.py root The root user is reserved // Print the result code of the last program executed $ echo $? 1 // 1 means there was an error, 0 means no errors. Tip The error code might be used by other programs (for example a Bash script) that execute with your CLI program. Abort \u00b6 There's a special exception that you can use to \"abort\" a program. It works more or less the same as typer.Exit() but will print \"Aborted!\" to the screen and can be useful in certain cases later to make it explicit that the execution was aborted: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Abort () typer . echo ( f \"New user created: {username} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Now make it exit with an error $ python main.py root The root user is reserved Aborted!","title":"Terminating"},{"location":"tutorial/terminating/#exit-a-cli-program","text":"You can normally just let the code of your CLI program finish its execution, but in some scenarios, you might want to terminate at some point in the middle of it. And prevent any subsequent code to run. This doesn't have to mean that there's an error, just that nothing else needs to be executed. In that case, you can raise a typer.Exit() exception: import typer existing_usernames = [ \"rick\" , \"morty\" ] def maybe_create_user ( username : str ): if username in existing_usernames : typer . echo ( \"The user already exists\" ) raise typer . Exit () else : typer . echo ( f \"User created: {username} \" ) def send_new_user_notification ( username : str ): # Somehow send a notification here for the new user, maybe an email typer . echo ( f \"Notification sent for new user: {username} \" ) def main ( username : str ): maybe_create_user ( username = username ) send_new_user_notification ( username = username ) if __name__ == \"__main__\" : typer . run ( main ) There are several things to see in this example. The CLI program is the function main() , not the others. This is the one that takes a CLI argument . The function maybe_create_user() can terminate the program by raising typer.Exit() . If the program is terminated by maybe_create_user() then send_new_user_notification() will never execute inside of main() . Check it: $ python main.py Camila User created: Camila Notification sent for new user: Camila // Try with an existing user $ python main.py rick The user already exists // Notice that the notification code was never run, the second message is not printed Tip Even though you are rasing an exception, it doesn't necessarily mean there's an error. This is done with an exception because it works as an \"error\" and stops all execution. But then Typer (actually Click) catches it and just terminates the program normally.","title":"Exit a CLI program"},{"location":"tutorial/terminating/#exit-with-an-error","text":"typer.Exit() takes an optional code parameter. By default, code is 0 , meaning there was no error. You can pass a code with a number other than 0 to tell the terminal that there was an error in the execution of the program: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Exit ( code = 1 ) typer . echo ( f \"New user created: {username} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Print the result code of the last program executed $ echo $? 0 // Now make it exit with an error $ python main.py root The root user is reserved // Print the result code of the last program executed $ echo $? 1 // 1 means there was an error, 0 means no errors. Tip The error code might be used by other programs (for example a Bash script) that execute with your CLI program.","title":"Exit with an error"},{"location":"tutorial/terminating/#abort","text":"There's a special exception that you can use to \"abort\" a program. It works more or less the same as typer.Exit() but will print \"Aborted!\" to the screen and can be useful in certain cases later to make it explicit that the execution was aborted: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Abort () typer . echo ( f \"New user created: {username} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Now make it exit with an error $ python main.py root The root user is reserved Aborted!","title":"Abort"},{"location":"tutorial/commands/","text":"We have seen how to create a CLI program with possibly several CLI Options and CLI Arguments . But Typer allows you to create CLI programs with several commands (also known as subcommands). For example, the program git has several commands. One command of git is git push . And git push in turn takes its own CLI arguments and CLI options . For example: // The push command with no parameters $ git push ---> 100% // The push command with one CLI option --set-upstream and 2 CLI arguments $ git push --set-upstream origin master ---> 100% Another command of git is git pull , it also has some CLI parameters . It's like if the same big program git had several small programs inside. Tip A command looks the same as a CLI argument , it's just some name without a preceding -- . But commands have predefined name, and are used to group different sets of functionalities into the same CLI application. Command or subcommand \u00b6 It's common to call a CLI program a \"command\". But when one of these programs have subcommands, those subcommands are also frequently called just \"commands\". Have that in mind so you don't get confused. Here I'll use CLI application or program to refer to the program you are building in Python with Typer, and command to refer to one of these \"subcommands\" of your program. Explicit application \u00b6 Before creating CLI applications with multiple commands/subcommands we need to understand how to create an explicit typer.Typer() application. In the CLI Options and CLI Argument tutorials you have seen how to create a single function and then pass that function to typer.run() . For example: import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) But that is actually a shortcut. Under the hood, Typer converts that to a CLI application with typer.Typer() and executes it. All that inside of typer.run() . There's also a more explicit way to achieve the same: import typer app = typer . Typer () @app . command () def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : app () When you use typer.run() , Typer is doing more or less the same as above, it will: Create a new typer.Typer() \"application\". Create a new \" command \" with your function. Call the same \"application\" as if it was a function with \" app() \". @decorator Info That @something syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells Typer that the function below is a \" command \". Both ways, with typer.run() and creating the explicit application, achieve the same. Tip If your use case is solved with just typer.run() , that's fine, you don't have to create the explicit app and use @app.command() , etc. You might want to do that later when your app needs the extra features, but if it doesn't need them yet, that's fine. If you run the second example, with the explicit app , it works exactly the same: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. A CLI application with multiple commands \u00b6 Coming back to the CLI applications with multiple commands/subcommands, Typer allows creating CLI applications with multiple of them. Now that you know how to create an explicit typer.Typer() application and add one command, let's see how to add multiple commands. Let's say that we have a CLI application to manage users. We'll have a command to create users and another command to delete them. To begin, let's say it can only create and delete one single predefined user: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . command () def delete (): typer . echo ( \"Deleting user: Hiro Hamada\" ) if __name__ == \"__main__\" : app () Now we have a CLI application with 2 commands, create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test them $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada // Now we have 2 commands! \ud83c\udf89 Notice that the help text now shows the 2 commands: create and delete . Tip By default, the names of the commands are generated from the function name. Decorator Technical Details \u00b6 When you use @app.command() the function under the decorator is registered in the Typer application and is then used later by the application. But Typer doesn't modify that function itself, the function is left as is. That means that if your function is simple enough that you could create it without using typer.Option() or typer.Argument() , you could use the same function for a Typer application and a FastAPI application putting both decorators on top, or similar tricks. Click Technical Details This behavior is a design difference with Click. In Click, when you add a @click.command() decorator it actually modifies the function underneath and replaces it with an object.","title":"Home"},{"location":"tutorial/commands/#command-or-subcommand","text":"It's common to call a CLI program a \"command\". But when one of these programs have subcommands, those subcommands are also frequently called just \"commands\". Have that in mind so you don't get confused. Here I'll use CLI application or program to refer to the program you are building in Python with Typer, and command to refer to one of these \"subcommands\" of your program.","title":"Command or subcommand"},{"location":"tutorial/commands/#explicit-application","text":"Before creating CLI applications with multiple commands/subcommands we need to understand how to create an explicit typer.Typer() application. In the CLI Options and CLI Argument tutorials you have seen how to create a single function and then pass that function to typer.run() . For example: import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) But that is actually a shortcut. Under the hood, Typer converts that to a CLI application with typer.Typer() and executes it. All that inside of typer.run() . There's also a more explicit way to achieve the same: import typer app = typer . Typer () @app . command () def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : app () When you use typer.run() , Typer is doing more or less the same as above, it will: Create a new typer.Typer() \"application\". Create a new \" command \" with your function. Call the same \"application\" as if it was a function with \" app() \". @decorator Info That @something syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells Typer that the function below is a \" command \". Both ways, with typer.run() and creating the explicit application, achieve the same. Tip If your use case is solved with just typer.run() , that's fine, you don't have to create the explicit app and use @app.command() , etc. You might want to do that later when your app needs the extra features, but if it doesn't need them yet, that's fine. If you run the second example, with the explicit app , it works exactly the same: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit.","title":"Explicit application"},{"location":"tutorial/commands/#a-cli-application-with-multiple-commands","text":"Coming back to the CLI applications with multiple commands/subcommands, Typer allows creating CLI applications with multiple of them. Now that you know how to create an explicit typer.Typer() application and add one command, let's see how to add multiple commands. Let's say that we have a CLI application to manage users. We'll have a command to create users and another command to delete them. To begin, let's say it can only create and delete one single predefined user: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . command () def delete (): typer . echo ( \"Deleting user: Hiro Hamada\" ) if __name__ == \"__main__\" : app () Now we have a CLI application with 2 commands, create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test them $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada // Now we have 2 commands! \ud83c\udf89 Notice that the help text now shows the 2 commands: create and delete . Tip By default, the names of the commands are generated from the function name.","title":"A CLI application with multiple commands"},{"location":"tutorial/commands/#decorator-technical-details","text":"When you use @app.command() the function under the decorator is registered in the Typer application and is then used later by the application. But Typer doesn't modify that function itself, the function is left as is. That means that if your function is simple enough that you could create it without using typer.Option() or typer.Argument() , you could use the same function for a Typer application and a FastAPI application putting both decorators on top, or similar tricks. Click Technical Details This behavior is a design difference with Click. In Click, when you add a @click.command() decorator it actually modifies the function underneath and replaces it with an object.","title":"Decorator Technical Details"},{"location":"tutorial/commands/arguments/","text":"The same way as with a CLI application with a single command, subcommands (or just \"commands\") can also have their own CLI arguments : import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: {username} \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: {username} \" ) if __name__ == \"__main__\" : app () // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Options: --help Show this message and exit. // Call it with a CLI argument $ python main.py create Camila Creating user: Camila // The same for delete $ python main.py delete Camila Deleting user: Camila Tip Everything to the right of the command are CLI parameters ( CLI arguments and CLI options ) for that command. Technical Details Actually, it's everything to the right of that command, before any subcommand . It's possible to have groups of subcommands , it's like if one command also had subcommands . And then those subcommands could have their own CLI parameters , taking their own CLI parameters . You will see about them later in another section.","title":"Arguments"},{"location":"tutorial/commands/callback/","text":"When you create an app = typer.Typer() it works as a group of commands. And you can create multiple commands with it. Each of those commands can have their own CLI parameters . But as those CLI parameters are handled by each of those commands, they don't allow us to create CLI parameters for the main CLI application itself. But we can use @app.callback() for that. It's very similar to @app.command() , but it declares the CLI parameters for the main CLI application (before the commands): import typer app = typer . Typer () state = { \"verbose\" : False } @app . command () def create ( username : str ): if state [ \"verbose\" ]: typer . echo ( \"About to create a user\" ) typer . echo ( f \"Creating user: {username} \" ) if state [ \"verbose\" ]: typer . echo ( \"Just created a user\" ) @app . command () def delete ( username : str ): if state [ \"verbose\" ]: typer . echo ( \"About to delete a user\" ) typer . echo ( f \"Deleting user: {username} \" ) if state [ \"verbose\" ]: typer . echo ( \"Just deleted a user\" ) @app . callback () def main ( verbose : bool = False ): \"\"\" Manage users in the awesome CLI app. \"\"\" if verbose : typer . echo ( \"Will write verbose output\" ) state [ \"verbose\" ] = True if __name__ == \"__main__\" : app () Here we create a callback with a --verbose CLI option . Tip After getting the --verbose flag, we modify a global state , and we use it in the other commands. There are other ways to achieve the same, but this will suffice for this example. And as we added a docstring to the callback function, by default it will be extracted and used as the help text. Check it: // Check the help $ python main.py --help // Notice the main help text, extracted from the callback function: \"Manage users in the awesome CLI app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users in the awesome CLI app. Options: --verbose / --no-verbose --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Check the new top level CLI option --verbose // Try it normally $ python main.py create Camila Creating user: Camila // And now with --verbose $ python main.py --verbose create Camila Will write verbose output About to create a user Creating user: Camila Just created a user // Notice that --verbose belongs to the callback, it has to go before create or delete \u26d4\ufe0f $ python main.py create --verbose Camila Usage: main.py create [OPTIONS] USERNAME Try \"main.py create --help\" for help. Error: no such option: --verbose Adding a callback on creation \u00b6 It's also possible to add a callback when creating the typer.Typer() app: import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () That achieves the same as with @app.callback() . Check it: $ python main.py create Camila Running a command Creating user: Camila Overriding a callback \u00b6 If you added a callback when creating the typer.Typer() app, it's possible to override it with @app.callback() : import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . callback () def new_callback (): typer . echo ( \"Override callback, running a command\" ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now new_callback() will be the one used. Check it: $ python main.py create Camila // Notice that the message is the one from new_callback() Override callback, running a command Creating user: Camila Adding a callback only for documentation \u00b6 You can also add a callback just to add the documentation in the docstring. It can be convenient especially if you have several lines of text, as the indentation will be automatically handled for you: import typer app = typer . Typer () @app . callback () def callback (): \"\"\" Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. \"\"\" @app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now the callback will be used mainly to extract the docstring for the help text. Check it: $ python main.py --help // Notice all the help text extracted from the callback docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it just works as normally $ python main.py create Camila Creating user: Camila","title":"Callback"},{"location":"tutorial/commands/callback/#adding-a-callback-on-creation","text":"It's also possible to add a callback when creating the typer.Typer() app: import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () That achieves the same as with @app.callback() . Check it: $ python main.py create Camila Running a command Creating user: Camila","title":"Adding a callback on creation"},{"location":"tutorial/commands/callback/#overriding-a-callback","text":"If you added a callback when creating the typer.Typer() app, it's possible to override it with @app.callback() : import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . callback () def new_callback (): typer . echo ( \"Override callback, running a command\" ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now new_callback() will be the one used. Check it: $ python main.py create Camila // Notice that the message is the one from new_callback() Override callback, running a command Creating user: Camila","title":"Overriding a callback"},{"location":"tutorial/commands/callback/#adding-a-callback-only-for-documentation","text":"You can also add a callback just to add the documentation in the docstring. It can be convenient especially if you have several lines of text, as the indentation will be automatically handled for you: import typer app = typer . Typer () @app . callback () def callback (): \"\"\" Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. \"\"\" @app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now the callback will be used mainly to extract the docstring for the help text. Check it: $ python main.py --help // Notice all the help text extracted from the callback docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it just works as normally $ python main.py create Camila Creating user: Camila","title":"Adding a callback only for documentation"},{"location":"tutorial/commands/help/","text":"The same as before, you can add help for the commands in the docstrings and the CLI options . And the typer.Typer() application receives a parameter help that you can pass with the main help text for your CLI program: import typer app = typer . Typer ( help = \"Awesome CLI user manager.\" ) @app . command () def create ( username : str ): \"\"\" Create a new user with USERNAME. \"\"\" typer . echo ( f \"Creating user: {username} \" ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete the user?\" , help = \"Force deletion without confirmation.\" , ), ): \"\"\" Delete a user with USERNAME. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( f \"Deleting user: {username} \" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete ALL users?\" , help = \"Force deletion without confirmation.\" , ) ): \"\"\" Delete ALL users in the database. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( \"Deleting all users\" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def init (): \"\"\" Initialize the users database. \"\"\" typer . echo ( \"Initializing user database\" ) if __name__ == \"__main__\" : app () Check it: // Check the new help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Awesome CLI user manager. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. delete-all Delete ALL users in the database. init Initialize the users database. // Now the commands have inline help \ud83c\udf89 // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Create a new user with USERNAME. Options: --help Show this message and exit. // Check the help for delete $ python main.py delete --help Usage: main.py delete [OPTIONS] USERNAME Delete a user with USERNAME. If --force is not used, will ask for confirmation. Options: --force / --no-force Force deletion without confirmation. [required] --help Show this message and exit. // Check the help for delete-all $ python main.py delete-all --help Usage: main.py delete-all [OPTIONS] Delete ALL users in the database. If --force is not used, will ask for confirmation. Options: --force / --no-force Force deletion without confirmation. [required] --help Show this message and exit. // Check the help for init $ python main.py init --help Usage: main.py init [OPTIONS] Initialize the users database. Options: --help Show this message and exit. Tip typer.Typer() receives several other parameters for other things, we'll see that later. You will also see how to use \"Callbacks\" later, and those include a way to add this same help message in a function docstring. Overwrite command help \u00b6 You will probably be better adding the help text as a docstring to your functions, but if for some reason you wanted to overwrite it, you can use the help function argument passed to @app.command() : import typer app = typer . Typer () @app . command ( help = \"Create a new user with USERNAME.\" ) def create ( username : str ): \"\"\" Some internal utility function to create. \"\"\" typer . echo ( f \"Creating user: {username} \" ) @app . command ( help = \"Delete a user with USERNAME.\" ) def delete ( username : str ): \"\"\" Some internal utility function to delete. \"\"\" typer . echo ( f \"Deleting user: {username} \" ) if __name__ == \"__main__\" : app () Check it: // Check the help $ python main.py --help // Notice it uses the help passed to @app.command() Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. // It uses \"Create a new user with USERNAME.\" instead of \"Some internal utility function to create.\"","title":"Help"},{"location":"tutorial/commands/help/#overwrite-command-help","text":"You will probably be better adding the help text as a docstring to your functions, but if for some reason you wanted to overwrite it, you can use the help function argument passed to @app.command() : import typer app = typer . Typer () @app . command ( help = \"Create a new user with USERNAME.\" ) def create ( username : str ): \"\"\" Some internal utility function to create. \"\"\" typer . echo ( f \"Creating user: {username} \" ) @app . command ( help = \"Delete a user with USERNAME.\" ) def delete ( username : str ): \"\"\" Some internal utility function to delete. \"\"\" typer . echo ( f \"Deleting user: {username} \" ) if __name__ == \"__main__\" : app () Check it: // Check the help $ python main.py --help // Notice it uses the help passed to @app.command() Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. // It uses \"Create a new user with USERNAME.\" instead of \"Some internal utility function to create.\"","title":"Overwrite command help"},{"location":"tutorial/commands/name/","text":"By default, the command names are generated from the function name. So, if your function is something like: def create ( username : str ): ... Then the command name will be create . But if you already had a function called create() somewhere in your code, you would have to name your CLI function differently. And what if you wanted the command to still be named create ? For this, you can set the name of the command in the first parameter for the @app.command() decorator: import typer app = typer . Typer () @app . command ( \"create\" ) def cli_create_user ( username : str ): typer . echo ( f \"Creating user: {username} \" ) @app . command ( \"delete\" ) def cli_delete_user ( username : str ): typer . echo ( f \"Deleting user: {username} \" ) if __name__ == \"__main__\" : app () Now, even though the functions are named cli_create_user() and cli_delete_user() , the commands will still be named create and delete : $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test it $ python main.py create Camila Creating user: Camila","title":"Name"},{"location":"tutorial/commands/one-or-multiple/","text":"You might have noticed that if you create a single command, as in the first example: import typer app = typer . Typer () @app . command () def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : app () Typer is smart enough to create a CLI application with that single function as the main CLI application, not as a command/subcommand: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that it doesn't show a command main , even though the function name is main . But if you add multiple commands, Typer will create one CLI command for each one of them: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . command () def delete (): typer . echo ( \"Deleting user: Hiro Hamada\" ) if __name__ == \"__main__\" : app () Here we have 2 commands create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test the commands $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada One command and one callback \u00b6 If you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): pass if __name__ == \"__main__\" : app () And now your CLI program will have a single command. Check it: // Check the help $ python main.py --help // Notice the single command create Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // Try it $ python main.py create Creating user: Hiro Hamada Using the callback to document \u00b6 Now that you are using a callback just to have a single command, you might as well use it to add documentation for your app: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): \"\"\" Creates a single user Hiro Hamada. In the next version it will create 5 users more. \"\"\" if __name__ == \"__main__\" : app () And now the docstring from the callback will be used as the help text: $ python main.py --help // Notice the help text from the docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Creates a single user Hiro Hamada. In the next version it will create 5 users more. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it still works the same, the callback does nothing $ python main.py create Creating user: Hiro Hamada","title":"One or multiple"},{"location":"tutorial/commands/one-or-multiple/#one-command-and-one-callback","text":"If you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): pass if __name__ == \"__main__\" : app () And now your CLI program will have a single command. Check it: // Check the help $ python main.py --help // Notice the single command create Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // Try it $ python main.py create Creating user: Hiro Hamada","title":"One command and one callback"},{"location":"tutorial/commands/one-or-multiple/#using-the-callback-to-document","text":"Now that you are using a callback just to have a single command, you might as well use it to add documentation for your app: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): \"\"\" Creates a single user Hiro Hamada. In the next version it will create 5 users more. \"\"\" if __name__ == \"__main__\" : app () And now the docstring from the callback will be used as the help text: $ python main.py --help // Notice the help text from the docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Creates a single user Hiro Hamada. In the next version it will create 5 users more. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it still works the same, the callback does nothing $ python main.py create Creating user: Hiro Hamada","title":"Using the callback to document"},{"location":"tutorial/commands/options/","text":"Commands can also have their own CLI options . In fact, each command can have different CLI arguments and CLI options : import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: {username} \" ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete the user?\" ), ): if force : typer . echo ( f \"Deleting user: {username} \" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete ALL users?\" ) ): if force : typer . echo ( \"Deleting all users\" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def init (): typer . echo ( \"Initializing user database\" ) if __name__ == \"__main__\" : app () Here we have multiple commands, with different CLI parameters : create : username : a CLI argument . delete : username : a CLI argument . --force : a CLI option , if not provided, it's prompted. delete-all : --force : a CLI option , if not provided, it's prompted. init : Doesn't take any CLI parameters . // Check the help python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete delete-all info Tip Check the command delete-all , by default command names are generated from the function name, replacing _ with - . Test it: // Check the command create $ python main.py create Camila Creating user: Camila // Now test the command delete $ python main.py delete Camila # Are you sure you want to delete the user? [ y/N ] : $ y Deleting user: Camila $ python main.py delete Wade # Are you sure you want to delete the user? [ y/N ] : $ n Operation cancelled // And finally, the command delete-all // Notice it doesn't have CLI arguments, only a CLI option $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/N ] : $ y Deleting all users $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/N ] : $ n Operation cancelled // And if you pass the --force CLI option, it doesn't need to confirm $ python main.py delete-all --force Deleting all users // And init that doesn't take any CLI parameter $ python main.py init Initializing user database","title":"Options"},{"location":"tutorial/multiple-values/","text":"There are several ways to declare multiple values for CLI options and CLI arguments . We'll see them in the next short sections.","title":"Home"},{"location":"tutorial/multiple-values/arguments-with-multiple-values/","text":"CLI arguments can also receive multiple values. You can define the type of a CLI argument using typing.List . from pathlib import Path from typing import List import typer def main ( files : List [ Path ], celebration : str ): for path in files : if path . is_file (): typer . echo ( f \"This file exists: {path.name} \" ) typer . echo ( celebration ) if __name__ == \"__main__\" : typer . run ( main ) And then you can pass it as many CLI arguments of that type as you want: $ python main.py ./index.md ./first-steps.md woohoo! This file exists: index.md woohoo! This file exists: first-steps.md woohoo! Tip We also declared a final CLI argument celebration , and it's correctly used even if we pass an arbitrary number of files first. Info A List can only be used in the last command (if there are subcommands), as this will take anything to the right and assume it's part of the expected CLI arguments .","title":"Arguments with multiple values"},{"location":"tutorial/multiple-values/multiple-options/","text":"You can declare a CLI option that can be used multiple times, and then get all the values. For example, let's say you want to accept several users in a single execution. For this, use the standard Python typing.List to declare it as a list of str : from typing import List import typer def main ( user : List [ str ] = typer . Option ( None )): if not user : typer . echo ( \"No provided users\" ) raise typer . Abort () for u in user : typer . echo ( f \"Processing user: {u} \" ) if __name__ == \"__main__\" : typer . run ( main ) You will receive the values as you declared them, as a list of str . Check it: $ python main.py No provided users Aborted! // Now pass a user $ python main.py --user Camila Processing user: Camila // And now try with several users $ python main.py --user Camila --user Rick --user Morty Processing user: Camila Processing user: Rick Processing user: Morty Multiple float \u00b6 The same way, you can use other types and they will be converted by Typer to their declared type: from typing import List import typer def main ( number : List [ float ] = typer . Option ([])): typer . echo ( f \"The sum is {sum(number)}\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py The sum is 0 // Try with some numbers $ python main.py --number 2 The sum is 2.0 // Try with some numbers $ python main.py --number 2 --number 3 --number 4 .5 The sum is 9.5","title":"Multiple options"},{"location":"tutorial/multiple-values/multiple-options/#multiple-float","text":"The same way, you can use other types and they will be converted by Typer to their declared type: from typing import List import typer def main ( number : List [ float ] = typer . Option ([])): typer . echo ( f \"The sum is {sum(number)}\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py The sum is 0 // Try with some numbers $ python main.py --number 2 The sum is 2.0 // Try with some numbers $ python main.py --number 2 --number 3 --number 4 .5 The sum is 9.5","title":"Multiple float"},{"location":"tutorial/multiple-values/options-with-multiple-values/","text":"You can also declare a CLI option that takes several values of different types. You can set the number of values and types to anything you want, but it has to be a fixed number of values. For this, use the standard Python typing.Tuple : from typing import Tuple import typer def main ( user : Tuple [ str , int , bool ] = typer . Option (( None , None , None ))): username , coins , is_wizard = user if not username : typer . echo ( \"No user provided\" ) raise typer . Abort () typer . echo ( f \"The username {username} has {coins} coins\" ) if is_wizard : typer . echo ( \"And this user is a wizard!\" ) if __name__ == \"__main__\" : typer . run ( main ) Each of the internal types defines the type of each value in the tuple. So: user : Tuple [ str , int , bool ] means that the parameter user is a tuple of 3 values. The first value is a str . The second value is an int . The third value is a bool . Later we do: username , coins , is_wizard = user If you hadn't seen that, it means that user is a tuple with 3 values, and we are assigning each of the values to a new variable: The first value in the tuple user (a str ) goes to the variable username . The second value in the tuple user (an int ) goes to the variable coins . The third value in the tuple user (a bool ) goes to the variable is_wizard . So, this: username , coins , is_wizard = user is equivalent to this: username = user [ 0 ] coins = user [ 1 ] is_wizard = user [ 2 ] Tip Notice that the default is a tuple with (None, None, None) . You cannot simply use None here as the default because Click doesn't support it . Check it \u00b6 Now let's see how this works in the terminal: // check the help $ python main.py --help // Notice the &lt;TEXT INTEGER BOOLEAN&gt; Usage: main.py [OPTIONS] Options: --user &lt;TEXT INTEGER BOOLEAN&gt;... --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Now try it $ python main.py --user Camila 50 yes The username Camila has 50 coins And this user is a wizard! // With other values $ python main.py --user Morty 3 no The username Morty has 3 coins // Try with invalid values (not enough) $ python main.py --user Camila 50 Error: --user option requires 3 arguments","title":"Options with multiple values"},{"location":"tutorial/multiple-values/options-with-multiple-values/#check-it","text":"Now let's see how this works in the terminal: // check the help $ python main.py --help // Notice the &lt;TEXT INTEGER BOOLEAN&gt; Usage: main.py [OPTIONS] Options: --user &lt;TEXT INTEGER BOOLEAN&gt;... --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Now try it $ python main.py --user Camila 50 yes The username Camila has 50 coins And this user is a wizard! // With other values $ python main.py --user Morty 3 no The username Morty has 3 coins // Try with invalid values (not enough) $ python main.py --user Camila 50 Error: --user option requires 3 arguments","title":"Check it"},{"location":"tutorial/options/","text":"In the next short sections we will see how to modify CLI options using typer.Option() . typer.Option() works very similarly to typer.Argument() , but has some extra features that we'll see next.","title":"Home"},{"location":"tutorial/options/help/","text":"In the First Steps section you saw how to add help for a CLI app/command by adding it to a function's docstring . Here's how that last example looked like: import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) Now we'll add a help section to the CLI options : import typer def main ( name : str , lastname : str = typer . Option ( \"\" , help = \"Last name of person to greet.\" ), formal : bool = typer . Option ( False , help = \"Say hi formally.\" ), ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. {name} {lastname} .\" ) else : typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) We are replacing the default values we had before with typer.Option() . As we no longer have a default value there, the first parameter to typer.Option() serves the same purpose of defining that default value. So, if we had: lastname : str = \"\" now we write: lastname : str = typer . Option ( \"\" ) And both forms achieve the same: a CLI option with a default value of an empty string ( \"\" ). And then we can pass the help keyword parameter: lastname : str = typer . Option ( \"\" , help = \"this option does this and that\" ) to create the help for that CLI option . Copy that example from above to a file main.py . Test it: $ python main.py --help Usage: main.py [OPTIONS] NAME Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. Options: --lastname TEXT Last name of person to greet. --formal / --no-formal Say hi formally. --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Now you have a help text for the --lastname and --formal CLI options \ud83c\udf89 Show default in help \u00b6 You can tell Typer to show the default value in the help text with show_default=True : import typer def main ( fullname : str = typer . Option ( \"Wade Wilson\" , show_default = True )): typer . echo ( f \"Hello {fullname} \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will show up in the help text: $ python main.py Hello Wade Wilson // Show the help $ python main.py --help Usage: main.py [OPTIONS] Options: --fullname TEXT [default: Wade Wilson] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice the [default: Wade Wilson] in the help text.","title":"Help"},{"location":"tutorial/options/help/#show-default-in-help","text":"You can tell Typer to show the default value in the help text with show_default=True : import typer def main ( fullname : str = typer . Option ( \"Wade Wilson\" , show_default = True )): typer . echo ( f \"Hello {fullname} \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will show up in the help text: $ python main.py Hello Wade Wilson // Show the help $ python main.py --help Usage: main.py [OPTIONS] Options: --fullname TEXT [default: Wade Wilson] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice the [default: Wade Wilson] in the help text.","title":"Show default in help"},{"location":"tutorial/options/name/","text":"By default Typer will create a CLI option name from the function parameter. So, if you have a function with: def main ( user_name : str = None ): pass or def main ( user_name : str = typer . Option ( None )): pass Typer will create a CLI option : --user-name But you can customize it if you want to. Let's say the function parameter name is user_name as above, but you want the CLI option to be just --name . You can pass the CLI option name that you want to have in the next positional argument passed to typer.Option() : import typer def main ( user_name : str = typer . Option ( ... , \"--name\" )): typer . echo ( f \"Hello {user_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Here you are passing the string \"--name\" as the second positional argument to typer.Option() . Info \" Positional \" means that it's not a function argument with a keyword name. For example show_default=True is a keyword argument. \" show_default \" is the keyword. But in \"--name\" there's no option_name=\"--name\" or something similar, it's just the string value \"--name\" that goes in typer.Option() after the ... value passed in the first position. That's a \"positional argument\" in a function. Check it: $ python main.py --help // Notice the --name instead of --user-name Usage: main.py [OPTIONS] Options: --name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python --name Camila Hello Camila CLI option short names \u00b6 A short name is a CLI option name with a single dash ( - ) instead of 2 ( -- ) and a single letter, like -n instead of --name . For example, the ls program has a CLI option named --size , and the same CLI option also has a short name -s : // With the long name --size $ ls ./myproject --size 12 first-steps.md 4 intro.md // With the short name -s $ ls ./myproject -s 12 first-steps.md 4 intro.md // Both CLI option names do the same CLI option short names together \u00b6 Short names have another feature, when they have a single letter, as in -s , you can put several of these CLI options together, with a single dash. For example, the ls program has these 2 CLI options (among others): --size : show the sizes of the listed files. --human : show a human-readable format, like 1MB instead of just 1024 . And these 2 CLI options have short versions too: --size : short version -s . --human : short version -h . So, you can put them together with -sh or -hs : // Call ls with long CLI options $ ls --size --human 12K first-steps.md 4.0K intro.md // Now with short versions $ ls -s -h 12K first-steps.md 4.0K intro.md // And with short versions together $ ls -sh 12K first-steps.md 4.0K intro.md // Order in short versions doesn't matter $ ls -hs 12K first-steps.md 4.0K intro.md // They all work the same \ud83c\udf89 CLI option short names with values \u00b6 When you use CLI options with short names, you can put them together if they are just boolean flags, like --size or --human . But if you have a CLI option --file with a short name -f that takes a value, if you put it with other short names for CLI options , you have to put it as the last letter, so that it can receive the value that comes right after. For example, let's say you are decompressing/extracting a file myproject.tar.gz with the program tar . You can pass these CLI option short names to tar : -x : means \"e X tract\", to decompress and extract the contents. -v : means \" V erbose\", to print on the screen what it is doing, so you can know that it's decompressing each file and can entertain yourself while you wait. -f : means \" F ile\", this one requires a value, the compressed file to extract (in our example, this is myproject.tar.gz ). So if you use all the short names together, this -f has to come last, to receive the value that comes next to it. For example: $ tar -xvf myproject.tar.gz myproject/ myproject/first-steps.md myproject/intro.md // But if you put the -f before $ tar -fxv myproject.tar.gz // You get an ugly error tar: You must specify one of the blah, blah, error, error Defining CLI option short names \u00b6 In Typer you can also define CLI option short names the same way you can customize the long names. typer.Option() receives as a first function argument the default value, e.g. None , and all the next positional values are to define the CLI option name(s). Tip Remember the positional function arguments are those that don't have a keyword. All the other function arguments/parameters you pass to typer.Option() like prompt=True and help=\"This option blah, blah\" require the keyword. You can overwrite the CLI option name to use as in the previous example, but you can also declare extra alternatives, including short names. For example, extending the previous example, let's add a CLI option short name -n : import typer def main ( user_name : str = typer . Option ( ... , \"--name\" , \"-n\" )): typer . echo ( f \"Hello {user_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Here we are overwriting the CLI option name that by default would be --user-name , and we are defining it to be --name . And we are also declaring a CLI option short name of -n . Check it: // Check the help $ python main.py --help // Notice the two CLI option names -n and --name Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short version $ python main.py -n Camila Hello Camila CLI option only short name \u00b6 If you only declare a short name like -n then that will be the only CLI option name. And neither --name nor --user-name will be available. import typer def main ( user_name : str = typer . Option ( ... , \"-n\" )): typer . echo ( f \"Hello {user_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no --name nor --user-name, only -n Usage: main.py [OPTIONS] Options: -n TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py -n Camila Hello Camila CLI option short name and default \u00b6 Continuing with the example above, as Typer allows you to declare a CLI option as having only a short name, if you want to have the default long name plus a short name, you have to declare both explicitly: import typer def main ( user_name : str = typer . Option ( ... , \"--user-name\" , \"-n\" )): typer . echo ( f \"Hello {user_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice that we have the long version --user-name back // and we also have the short version -n Usage: main.py [OPTIONS] Options: -n, --user-name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py --user-name Camila Hello Camila // And try the short version $ python main.py -n Camila CLI option short names together \u00b6 You can create multiple short names and use them together. You don't have to do anything special for it to work (apart from declaring those short versions): import typer def main ( name : str = typer . Option ( ... , \"--name\" , \"-n\" ), formal : bool = typer . Option ( False , \"--formal\" , \"-f\" ), ): if formal : typer . echo ( f \"Good day Ms. {name} .\" ) else : typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that, again, we are declaring the long and short version of the CLI option names. Check it: $ python main.py --help // We now have short versions -n and -f // And also long versions --name and --formal Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] -f, --formal --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short versions $ python main.py -n Camila -f Good day Ms. Camila. // And try the 2 short versions together // See how -n has to go last, to be able to get the value $ python main.py -fn Camila Good day Ms. Camila.","title":"Name"},{"location":"tutorial/options/name/#cli-option-short-names","text":"A short name is a CLI option name with a single dash ( - ) instead of 2 ( -- ) and a single letter, like -n instead of --name . For example, the ls program has a CLI option named --size , and the same CLI option also has a short name -s : // With the long name --size $ ls ./myproject --size 12 first-steps.md 4 intro.md // With the short name -s $ ls ./myproject -s 12 first-steps.md 4 intro.md // Both CLI option names do the same","title":"CLI option short names"},{"location":"tutorial/options/name/#cli-option-short-names-together","text":"Short names have another feature, when they have a single letter, as in -s , you can put several of these CLI options together, with a single dash. For example, the ls program has these 2 CLI options (among others): --size : show the sizes of the listed files. --human : show a human-readable format, like 1MB instead of just 1024 . And these 2 CLI options have short versions too: --size : short version -s . --human : short version -h . So, you can put them together with -sh or -hs : // Call ls with long CLI options $ ls --size --human 12K first-steps.md 4.0K intro.md // Now with short versions $ ls -s -h 12K first-steps.md 4.0K intro.md // And with short versions together $ ls -sh 12K first-steps.md 4.0K intro.md // Order in short versions doesn't matter $ ls -hs 12K first-steps.md 4.0K intro.md // They all work the same \ud83c\udf89","title":"CLI option short names together"},{"location":"tutorial/options/name/#cli-option-short-names-with-values","text":"When you use CLI options with short names, you can put them together if they are just boolean flags, like --size or --human . But if you have a CLI option --file with a short name -f that takes a value, if you put it with other short names for CLI options , you have to put it as the last letter, so that it can receive the value that comes right after. For example, let's say you are decompressing/extracting a file myproject.tar.gz with the program tar . You can pass these CLI option short names to tar : -x : means \"e X tract\", to decompress and extract the contents. -v : means \" V erbose\", to print on the screen what it is doing, so you can know that it's decompressing each file and can entertain yourself while you wait. -f : means \" F ile\", this one requires a value, the compressed file to extract (in our example, this is myproject.tar.gz ). So if you use all the short names together, this -f has to come last, to receive the value that comes next to it. For example: $ tar -xvf myproject.tar.gz myproject/ myproject/first-steps.md myproject/intro.md // But if you put the -f before $ tar -fxv myproject.tar.gz // You get an ugly error tar: You must specify one of the blah, blah, error, error","title":"CLI option short names with values"},{"location":"tutorial/options/name/#defining-cli-option-short-names","text":"In Typer you can also define CLI option short names the same way you can customize the long names. typer.Option() receives as a first function argument the default value, e.g. None , and all the next positional values are to define the CLI option name(s). Tip Remember the positional function arguments are those that don't have a keyword. All the other function arguments/parameters you pass to typer.Option() like prompt=True and help=\"This option blah, blah\" require the keyword. You can overwrite the CLI option name to use as in the previous example, but you can also declare extra alternatives, including short names. For example, extending the previous example, let's add a CLI option short name -n : import typer def main ( user_name : str = typer . Option ( ... , \"--name\" , \"-n\" )): typer . echo ( f \"Hello {user_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Here we are overwriting the CLI option name that by default would be --user-name , and we are defining it to be --name . And we are also declaring a CLI option short name of -n . Check it: // Check the help $ python main.py --help // Notice the two CLI option names -n and --name Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short version $ python main.py -n Camila Hello Camila","title":"Defining CLI option short names"},{"location":"tutorial/options/name/#cli-option-only-short-name","text":"If you only declare a short name like -n then that will be the only CLI option name. And neither --name nor --user-name will be available. import typer def main ( user_name : str = typer . Option ( ... , \"-n\" )): typer . echo ( f \"Hello {user_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no --name nor --user-name, only -n Usage: main.py [OPTIONS] Options: -n TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py -n Camila Hello Camila","title":"CLI option only short name"},{"location":"tutorial/options/name/#cli-option-short-name-and-default","text":"Continuing with the example above, as Typer allows you to declare a CLI option as having only a short name, if you want to have the default long name plus a short name, you have to declare both explicitly: import typer def main ( user_name : str = typer . Option ( ... , \"--user-name\" , \"-n\" )): typer . echo ( f \"Hello {user_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice that we have the long version --user-name back // and we also have the short version -n Usage: main.py [OPTIONS] Options: -n, --user-name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py --user-name Camila Hello Camila // And try the short version $ python main.py -n Camila","title":"CLI option short name and default"},{"location":"tutorial/options/name/#cli-option-short-names-together_1","text":"You can create multiple short names and use them together. You don't have to do anything special for it to work (apart from declaring those short versions): import typer def main ( name : str = typer . Option ( ... , \"--name\" , \"-n\" ), formal : bool = typer . Option ( False , \"--formal\" , \"-f\" ), ): if formal : typer . echo ( f \"Good day Ms. {name} .\" ) else : typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that, again, we are declaring the long and short version of the CLI option names. Check it: $ python main.py --help // We now have short versions -n and -f // And also long versions --name and --formal Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] -f, --formal --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short versions $ python main.py -n Camila -f Good day Ms. Camila. // And try the 2 short versions together // See how -n has to go last, to be able to get the value $ python main.py -fn Camila Good day Ms. Camila.","title":"CLI option short names together"},{"location":"tutorial/options/prompt/","text":"It's also possible to, instead of just showing an error, ask for the missing value with prompt=True : import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = True )): typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) And then your program will ask the user for it in the terminal: // Call it with the NAME CLI argument $ python main.py Camila // It asks for the missing CLI option --lastname # Lastname: $ Guti\u00e9rrez Hello Camila Guti\u00e9rrez Customize the prompt \u00b6 You can also set a custom prompt, passing the string that you want to use instead of just True : import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = \"Please tell me your last name\" ), ): typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) And then your program will ask for it using with your custom prompt: // Call it with the NAME CLI argument $ python main.py Camila // It uses the custom prompt # Please tell me your last name: $ Guti\u00e9rrez Hello Camila Guti\u00e9rrez Confirmation prompt \u00b6 In some cases you could want to prompt for something and then ask the user to confirm it by typing it twice. You can do it passing the parameter confirmation_prompt=True . Let's say it's a CLI app to delete a project: import typer def main ( project_name : str = typer . Option ( ... , prompt = True , confirmation_prompt = True )): typer . echo ( f \"Deleting project {project_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will prompt the user for a value and then for the confirmation: $ python main.py // Your app will first prompt for the project name, and then for the confirmation # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // If the user doesn't type the same, receives an error and a new prompt $ python main.py # Project name: $ Old Project # Repeat for confirmation: $ New Spice Error: the two entered values do not match # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // Now it works \ud83c\udf89","title":"Prompt"},{"location":"tutorial/options/prompt/#customize-the-prompt","text":"You can also set a custom prompt, passing the string that you want to use instead of just True : import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = \"Please tell me your last name\" ), ): typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) And then your program will ask for it using with your custom prompt: // Call it with the NAME CLI argument $ python main.py Camila // It uses the custom prompt # Please tell me your last name: $ Guti\u00e9rrez Hello Camila Guti\u00e9rrez","title":"Customize the prompt"},{"location":"tutorial/options/prompt/#confirmation-prompt","text":"In some cases you could want to prompt for something and then ask the user to confirm it by typing it twice. You can do it passing the parameter confirmation_prompt=True . Let's say it's a CLI app to delete a project: import typer def main ( project_name : str = typer . Option ( ... , prompt = True , confirmation_prompt = True )): typer . echo ( f \"Deleting project {project_name} \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will prompt the user for a value and then for the confirmation: $ python main.py // Your app will first prompt for the project name, and then for the confirmation # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // If the user doesn't type the same, receives an error and a new prompt $ python main.py # Project name: $ Old Project # Repeat for confirmation: $ New Spice Error: the two entered values do not match # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // Now it works \ud83c\udf89","title":"Confirmation prompt"},{"location":"tutorial/options/required/","text":"We said before that by default : CLI options are optional CLI arguments are required Well, that's how they work by default , and that's the convention in many CLI programs and systems. But if you really want, you can change that. To make a CLI option required, pass ... to typer.Option() . Info If you hadn't seen that ... before: it is a a special single value, it is part of Python and is called \"Ellipsis\" . That will tell Typer that it's still a CLI option , but it doesn't have a default value, and it's required. Let's make --lastname a required CLI option : import typer def main ( name : str , lastname : str = typer . Option ( ... )): typer . echo ( f \"Hello {name} {lastname} \" ) if __name__ == \"__main__\" : typer . run ( main ) And test it: // Pass the NAME CLI argument $ python main.py Camila // We didn't pass the now required --lastname CLI option Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing option \"--lastname\". // Now update it to pass the required --lastname CLI option $ python main.py Camila --lastname Guti\u00e9rrez Hello Camila Guti\u00e9rrez // And if you check the help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --lastname TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // It now tells you that --lastname is required \ud83c\udf89","title":"Required"},{"location":"tutorial/parameter-types/","text":"You can use several data types for the CLI options and CLI arguments , and you can add data validation requirements too. Data conversion \u00b6 When you declare a CLI parameter with some type Typer will convert the data received in the command line to that data type. For example: import typer def main ( name : str , age : int = 20 , height_meters : float = 1.89 , female : bool = True , ): typer . echo ( f \"NAME is {name} , of type: {type(name)}\" ) typer . echo ( f \"--age is {age} , of type: {type(age)}\" ) typer . echo ( f \"--height-meters is {height_meters} , of type: {type(height_meters)}\" ) typer . echo ( f \"--female is {female} , of type: {type(female)}\" ) if __name__ == \"__main__\" : typer . run ( main ) In this example, the value received for the CLI argument NAME will be treated as str . The value for the CLI option --age will be converted to an int and --height-meters will be converted to a float . And as female is a bool CLI option , Typer will convert it to a \"flag\" --female and the counterpart --no-female . And here's how it looks like: $ python main.py --help // Notice how --age is an INTEGER and --height-meters is a FLOAT Usage: main.py [OPTIONS] NAME Options: --age INTEGER --height-meters FLOAT --female / --no-female --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Call it with CLI parameters $ python main.py Camila --age 15 --height-meters 1 .70 --female // All the data has the correct Python type NAME is Camila, of type: class 'str' --age is 15, of type: class 'int' --height-meters is 1.7, of type: class 'float' --female is True, of type: class 'bool' // And if you pass an incorrect type $ python main.py Camila --age 15 .3 Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Invalid value for \"--age\": 15.3 is not a valid integer // Because 15.3 is not an INTEGER (it's a float) Watch next \u00b6 See more about specific types and validations in the next sections... Technical Details All the types you will see in the next sections are handled underneath by Click's Parameter Types .","title":"Home"},{"location":"tutorial/parameter-types/#data-conversion","text":"When you declare a CLI parameter with some type Typer will convert the data received in the command line to that data type. For example: import typer def main ( name : str , age : int = 20 , height_meters : float = 1.89 , female : bool = True , ): typer . echo ( f \"NAME is {name} , of type: {type(name)}\" ) typer . echo ( f \"--age is {age} , of type: {type(age)}\" ) typer . echo ( f \"--height-meters is {height_meters} , of type: {type(height_meters)}\" ) typer . echo ( f \"--female is {female} , of type: {type(female)}\" ) if __name__ == \"__main__\" : typer . run ( main ) In this example, the value received for the CLI argument NAME will be treated as str . The value for the CLI option --age will be converted to an int and --height-meters will be converted to a float . And as female is a bool CLI option , Typer will convert it to a \"flag\" --female and the counterpart --no-female . And here's how it looks like: $ python main.py --help // Notice how --age is an INTEGER and --height-meters is a FLOAT Usage: main.py [OPTIONS] NAME Options: --age INTEGER --height-meters FLOAT --female / --no-female --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Call it with CLI parameters $ python main.py Camila --age 15 --height-meters 1 .70 --female // All the data has the correct Python type NAME is Camila, of type: class 'str' --age is 15, of type: class 'int' --height-meters is 1.7, of type: class 'float' --female is True, of type: class 'bool' // And if you pass an incorrect type $ python main.py Camila --age 15 .3 Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Invalid value for \"--age\": 15.3 is not a valid integer // Because 15.3 is not an INTEGER (it's a float)","title":"Data conversion"},{"location":"tutorial/parameter-types/#watch-next","text":"See more about specific types and validations in the next sections... Technical Details All the types you will see in the next sections are handled underneath by Click's Parameter Types .","title":"Watch next"},{"location":"tutorial/parameter-types/bool/","text":"We have seen some examples of CLI options with bool , and how Typer creates --something and --no-something automatically. But we can customize those names. Only --force \u00b6 Let's say that we want a --force CLI option only, we want to discard --no-force . We can do that by specifying the exact name we want: import typer def main ( force : bool = typer . Option ( False , \"--force\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Now there's only a --force CLI option : // Check the help $ python main.py --help // Notice there's only --force, we no longer have --no-force Usage: main.py [OPTIONS] Options: --force --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it: $ python main.py Not forcing // Now add --force $ python main.py --force Forcing operation // And --no-force no longer exists \u26d4\ufe0f $ python main.py --no-force Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: no such option: --no-force Alternative names \u00b6 Now let's imagine we have a CLI option --accept . And we want to allow setting --accept or the contrary, but --no-accept looks ugly. We might want to instead have --accept and --reject . We can do that by passing a single str with the 2 names for the bool CLI option separated by / : import typer def main ( accept : bool = typer . Option ( None , \"--accept/--reject\" )): if accept is None : typer . echo ( \"I don't know what you want yet\" ) elif accept : typer . echo ( \"Accepting!\" ) else : typer . echo ( \"Rejecting!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the --accept / --reject Usage: main.py [OPTIONS] Options: --accept / --reject --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py I don't know what you want yet // Now pass --accept $ python main.py --accept Accepting! // And --reject $ python main.py --reject Rejecting! Short names \u00b6 The same way, you can declare short versions of the names for these CLI options . For example, let's say we want -f for --force and -F for --no-force : import typer def main ( force : bool = typer . Option ( False , \"--force/--no-force\" , \"-f/-F\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the -f, --force / -F, --no-force Usage: main.py [OPTIONS] Options: -f, --force / -F, --no-force --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try with the short name -f $ python main.py -f Forcing operation // Try with the short name -F $ python main.py -F Not forcing Only names for False \u00b6 If you want to (although it might not be a good idea), you can declare only CLI option names to set the False value. To do that, use a space and a single / and pass the negative name after: import typer def main ( in_prod : bool = typer . Option ( True , \" /--demo\" , \" /-d\" )): if in_prod : typer . echo ( \"Running in production\" ) else : typer . echo ( \"Running demo\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Have in mind that it's a string with a preceding space and then a / . So, it's \" /-S\" not \"/-S\" . Check it: // Check the help $ python main.py --help // Notice the / -d, --demo Usage: main.py [OPTIONS] Options: / -d, --demo --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py Running in production // Now pass --demo $ python main.py --demo Running demo // And the short version $ python main.py -d Running demo","title":"Bool"},{"location":"tutorial/parameter-types/bool/#only-force","text":"Let's say that we want a --force CLI option only, we want to discard --no-force . We can do that by specifying the exact name we want: import typer def main ( force : bool = typer . Option ( False , \"--force\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Now there's only a --force CLI option : // Check the help $ python main.py --help // Notice there's only --force, we no longer have --no-force Usage: main.py [OPTIONS] Options: --force --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it: $ python main.py Not forcing // Now add --force $ python main.py --force Forcing operation // And --no-force no longer exists \u26d4\ufe0f $ python main.py --no-force Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: no such option: --no-force","title":"Only --force"},{"location":"tutorial/parameter-types/bool/#alternative-names","text":"Now let's imagine we have a CLI option --accept . And we want to allow setting --accept or the contrary, but --no-accept looks ugly. We might want to instead have --accept and --reject . We can do that by passing a single str with the 2 names for the bool CLI option separated by / : import typer def main ( accept : bool = typer . Option ( None , \"--accept/--reject\" )): if accept is None : typer . echo ( \"I don't know what you want yet\" ) elif accept : typer . echo ( \"Accepting!\" ) else : typer . echo ( \"Rejecting!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the --accept / --reject Usage: main.py [OPTIONS] Options: --accept / --reject --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py I don't know what you want yet // Now pass --accept $ python main.py --accept Accepting! // And --reject $ python main.py --reject Rejecting!","title":"Alternative names"},{"location":"tutorial/parameter-types/bool/#short-names","text":"The same way, you can declare short versions of the names for these CLI options . For example, let's say we want -f for --force and -F for --no-force : import typer def main ( force : bool = typer . Option ( False , \"--force/--no-force\" , \"-f/-F\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the -f, --force / -F, --no-force Usage: main.py [OPTIONS] Options: -f, --force / -F, --no-force --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try with the short name -f $ python main.py -f Forcing operation // Try with the short name -F $ python main.py -F Not forcing","title":"Short names"},{"location":"tutorial/parameter-types/bool/#only-names-for-false","text":"If you want to (although it might not be a good idea), you can declare only CLI option names to set the False value. To do that, use a space and a single / and pass the negative name after: import typer def main ( in_prod : bool = typer . Option ( True , \" /--demo\" , \" /-d\" )): if in_prod : typer . echo ( \"Running in production\" ) else : typer . echo ( \"Running demo\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Have in mind that it's a string with a preceding space and then a / . So, it's \" /-S\" not \"/-S\" . Check it: // Check the help $ python main.py --help // Notice the / -d, --demo Usage: main.py [OPTIONS] Options: / -d, --demo --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py Running in production // Now pass --demo $ python main.py --demo Running demo // And the short version $ python main.py -d Running demo","title":"Only names for False"},{"location":"tutorial/parameter-types/datetime/","text":"You can specify a CLI parameter as a Python datetime . Your function will receive a standard Python datetime object, and again, your editor will give you completion, etc. from datetime import datetime import typer def main ( birth : datetime ): typer . echo ( f \"Interesting day to be born: {birth} \" ) typer . echo ( f \"Birth hour: {birth.hour} \" ) if __name__ == \"__main__\" : typer . run ( main ) By default, it will expect a datetime in ISO format in the input. Check it: $ python main.py --help Usage: main.py [OPTIONS] [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Pass a datetime $ python main.py 1956 -01-31T10:00:00 Interesting day to be born: 1956-01-31 10:00:00 Birth hour: 10 // An invalid date $ python main.py july-19-1989 Usage: main.py [OPTIONS] [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d%H:%M:%S] Error: Invalid value for \"[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\": invalid datetime format: july-19-1989. (choose from %Y-%m-%d, %Y-%m-%dT%H:%M:%S, %Y-%m-%d %H:%M:%S) Custom date format \u00b6 You can also customize the formats received for the datetime with the formats parameter. formats receives a list of strings with the date formats that would be passed to datetime.strptime() . For example, let's imagine that you want to accept an ISO formatted datetime, but for some strange reason, you also want to accept a format with: first the month then the day then the year separated with \" / \" ...It's a crazy example, but let's say you also needed that strange format: from datetime import datetime import typer def main ( launch_date : datetime = typer . Argument ( ... , formats = [ \"%Y-%m- %d \" , \"%Y-%m- %d T%H:%M:%S\" , \"%Y-%m- %d %H:%M:%S\" , \"%m/ %d /%Y\" ] ) ): typer . echo ( f \"Launch will be at: {launch_date} \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice the last string in formats : \"%m/%d/%Y\" . Check it: // ISO dates work $ python main.py 1969 -10-29 Launch will be at: 1969-10-29 00:00:00 // But the strange custom format also works $ python main.py 10 /29/1969 Launch will be at: 1969-10-29 00:00:00","title":"Datetime"},{"location":"tutorial/parameter-types/datetime/#custom-date-format","text":"You can also customize the formats received for the datetime with the formats parameter. formats receives a list of strings with the date formats that would be passed to datetime.strptime() . For example, let's imagine that you want to accept an ISO formatted datetime, but for some strange reason, you also want to accept a format with: first the month then the day then the year separated with \" / \" ...It's a crazy example, but let's say you also needed that strange format: from datetime import datetime import typer def main ( launch_date : datetime = typer . Argument ( ... , formats = [ \"%Y-%m- %d \" , \"%Y-%m- %d T%H:%M:%S\" , \"%Y-%m- %d %H:%M:%S\" , \"%m/ %d /%Y\" ] ) ): typer . echo ( f \"Launch will be at: {launch_date} \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice the last string in formats : \"%m/%d/%Y\" . Check it: // ISO dates work $ python main.py 1969 -10-29 Launch will be at: 1969-10-29 00:00:00 // But the strange custom format also works $ python main.py 10 /29/1969 Launch will be at: 1969-10-29 00:00:00","title":"Custom date format"},{"location":"tutorial/parameter-types/enum/","text":"To define a CLI parameter that can take a value from a predefined set of values you can use a standard Python enum.Enum : from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = \"simple\" conv = \"conv\" lstm = \"lstm\" def main ( network : NeuralNetwork = NeuralNetwork . simple ): typer . echo ( f \"Training neural network of type: {network.value} \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that the function parameter network will be an Enum , not a str . To get the str value in your function's code use network.value . Check it: $ python main.py --help // Notice the predefined values [simple|conv|lstm] Usage: main.py [OPTIONS] Options: --network [simple|conv|lstm] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py --network conv Training neural network of type: conv // Invalid value $ python main.py --network capsule Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for \"--network\": invalid choice: capsule. (choose from simple, conv, lstm) Case insensitive Enum choices \u00b6 You can make an Enum (choice) CLI parameter be case-insensitive with the case_sensitive parameter: from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = \"simple\" conv = \"conv\" lstm = \"lstm\" def main ( network : NeuralNetwork = typer . Option ( NeuralNetwork . simple , case_sensitive = False ) ): typer . echo ( f \"Training neural network of type: {network.value} \" ) if __name__ == \"__main__\" : typer . run ( main ) And then the values of the Enum will be checked no matter if lower case, upper case, or a mix: // Notice the upper case CONV $ python main.py --network CONV Training neural network of type: conv // A mix also works $ python main.py --network LsTm Training neural network of type: lstm","title":"Enum"},{"location":"tutorial/parameter-types/enum/#case-insensitive-enum-choices","text":"You can make an Enum (choice) CLI parameter be case-insensitive with the case_sensitive parameter: from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = \"simple\" conv = \"conv\" lstm = \"lstm\" def main ( network : NeuralNetwork = typer . Option ( NeuralNetwork . simple , case_sensitive = False ) ): typer . echo ( f \"Training neural network of type: {network.value} \" ) if __name__ == \"__main__\" : typer . run ( main ) And then the values of the Enum will be checked no matter if lower case, upper case, or a mix: // Notice the upper case CONV $ python main.py --network CONV Training neural network of type: conv // A mix also works $ python main.py --network LsTm Training neural network of type: lstm","title":"Case insensitive Enum choices"},{"location":"tutorial/parameter-types/file/","text":"Apart from Path CLI parameters you can also declare some types of \"files\". Tip In most of the cases you are probably fine just using Path . You can read and write data with Path the same way. The difference is that these types will give you a Python file-like object instead of a Python Path . A \"file-like object\" is the same type of object returned by open() as in: with open ( 'file.txt' ) as f : # Here f is the file-like object read_data = f . read () print ( read_data ) But in some special use cases you might want to use these special types. For example if you are migrating an existing application. FileText reading \u00b6 typer.FileText gives you a file-like object for reading text, you will get str data from it. This means that even if your file has text written in a non-english language, e.g. a text.txt file with: la cig\u00fce\u00f1a trae al ni\u00f1o You will have a str with the text inside, e.g.: content = \"la cig\u00fce\u00f1a trae al ni\u00f1o\" instead of having bytes , e.g.: content = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" You will get all the correct editor support, attributes, methods, etc for the file-like object: import typer def main ( config : typer . FileText = typer . Option ( ... )): for line in config : typer . echo ( f \"Config line: {line} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Create a quick text config $ echo \"some settings\" > config.txt // Add another line to the config to test it $ echo \"some more settings\" >> config.txt // Now run your program $ python main.py --config config.txt Config line: some settings Config line: some more settings FileTextWrite \u00b6 For writing text, you can use typer.FileTextWrite : import typer def main ( config : typer . FileTextWrite = typer . Option ( ... )): config . write ( \"Some config written by the app\" ) typer . echo ( \"Config written\" ) if __name__ == \"__main__\" : typer . run ( main ) This would be for writing human text, like: some settings la cig\u00fce\u00f1a trae al ni\u00f1o ...not to write binary bytes . Check it: $ python main.py --config text.txt Config written // Check the contents of the file $ cat text.txt Some config written by the app Technical Details typer.FileTextWrite is a just a convenience class. It's the same as using typer.FileText and setting mode=\"w\" . You will learn about mode later below. FileBinaryRead \u00b6 To read binary data you can use typer.FileBinaryRead . You will receive bytes from it. It's useful for reading binary files like images: import typer def main ( file : typer . FileBinaryRead = typer . Option ( ... )): processed_total = 0 for bytes_chunk in file : # Process the bytes in bytes_chunk processed_total += len ( bytes_chunk ) typer . echo ( f \"Processed bytes total: {processed_total} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --file lena.jpg Processed bytes total: 512 Processed bytes total: 1024 Processed bytes total: 1536 Processed bytes total: 2048 FileBinaryWrite \u00b6 To write binary data you can use typer.FileBinaryWrite . You would write bytes to it. It's useful for writing binary files like images. Have in mind that you have to pass bytes to its .write() method, not str . If you have a str , you have to encode it first to get bytes . import typer def main ( file : typer . FileBinaryWrite = typer . Option ( ... )): first_line_str = \"some settings \\n \" # You cannot write str directly to a binary file, you have to encode it to get bytes first_line_bytes = first_line_str . encode ( \"utf-8\" ) # Then you can write the bytes file . write ( first_line_bytes ) # This is already bytes, it starts with b\" second_line = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" file . write ( second_line ) typer . echo ( \"Binary file written\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py --file binary.dat Binary file written // Check the binary file was created $ ls ./binary.dat ./binary.dat File CLI parameter configurations \u00b6 You can use several configuration parameters for these types (classes) in typer.Option() and typer.Argument() : mode : controls the \" mode \" to open the file with. It's automatically set for you by using the classes above. Read more about it below. encoding : to force a specific encoding, e.g. \"utf-8\" . lazy : delay I/O operations. Automatic by default. By default, when writing files, Click will generate a file-like object that is not yet the actual file. Once you start writing, it will go, open the file and start writing to it, but not before. This is mainly useful to avoid creating the file until you start writing to it. It's normally safe to leave this automatic. But you can overwrite it setting lazy=False . By default, it's lazy=True for writing and lazy=False for reading. atomic : if true, all writes will actually go to a temporal file and then moved to the final destination after completing. This is useful with files modified frequently by several users/programs. Advanced mode \u00b6 By default, Typer will configure the mode for you: typer.FileText : mode=\"r\" , to read text. typer.FileTextWrite : mode=\"w\" , to write text. typer.FileBinaryRead : mode=\"rb\" , to read binary data. typer.FileBinaryWrite : mode=\"wb\" , to write binary data. Note about FileTextWrite \u00b6 typer.FileTextWrite is actually just a convenience class. It's the same as using typer.FileText with mode=\"w\" . But it's probably shorter and more intuitive as you can get it with autocompletion in your editor by just starting to type typer.File ... just like the other classes. Customize mode \u00b6 You can override the mode from the defaults above. For example, you could use mode=\"a\" to write \"appending\" to the same file: import typer def main ( config : typer . FileText = typer . Option ( ... , mode = \"a\" )): config . write ( \"This is a single line \\n \" ) typer . echo ( \"Config line written\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip As you are manually setting mode=\"a\" , you can use typer.FileText or typer.FileTextWrite , both will work. Check it: $ python main.py --config config.txt Config line written // Run your program a couple more times to see how it appends instead of overwriting $ python main.py --config config.txt Config line written $ python main.py --config config.txt Config line written // Check the contents of the file, it should have each of the 3 lines appended $ cat config.txt This is a single line This is a single line This is a single line About the different types \u00b6 Info These are technical details about why the different types/classes provided by Typer . But you don't need this information to be able to use them. You can skip it. Typer provides you these different types (classes) because they inherit directly from the actual Python implementation that will be provided underneath for each case. This way your editor will give you the right type checks and completion for each type. Even if you use lazy . When you use lazy Click creates a especial object to delay writes, and serves as a \"proxy\" to the actual file that will be written. But this especial proxy object doesn't expose the attributes and methods needed for type checks and completion in the editor. If you access those attributes or call the methods, the \"proxy\" lazy object will call them in the final object and it will all work. But you wouldn't get autocompletion for them. But because these Typer classes inherit from the actual implementation that will be provided underneath (not the lazy object), you will get all the autocompletion and type checks in the editor.","title":"File"},{"location":"tutorial/parameter-types/file/#filetext-reading","text":"typer.FileText gives you a file-like object for reading text, you will get str data from it. This means that even if your file has text written in a non-english language, e.g. a text.txt file with: la cig\u00fce\u00f1a trae al ni\u00f1o You will have a str with the text inside, e.g.: content = \"la cig\u00fce\u00f1a trae al ni\u00f1o\" instead of having bytes , e.g.: content = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" You will get all the correct editor support, attributes, methods, etc for the file-like object: import typer def main ( config : typer . FileText = typer . Option ( ... )): for line in config : typer . echo ( f \"Config line: {line} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Create a quick text config $ echo \"some settings\" > config.txt // Add another line to the config to test it $ echo \"some more settings\" >> config.txt // Now run your program $ python main.py --config config.txt Config line: some settings Config line: some more settings","title":"FileText reading"},{"location":"tutorial/parameter-types/file/#filetextwrite","text":"For writing text, you can use typer.FileTextWrite : import typer def main ( config : typer . FileTextWrite = typer . Option ( ... )): config . write ( \"Some config written by the app\" ) typer . echo ( \"Config written\" ) if __name__ == \"__main__\" : typer . run ( main ) This would be for writing human text, like: some settings la cig\u00fce\u00f1a trae al ni\u00f1o ...not to write binary bytes . Check it: $ python main.py --config text.txt Config written // Check the contents of the file $ cat text.txt Some config written by the app Technical Details typer.FileTextWrite is a just a convenience class. It's the same as using typer.FileText and setting mode=\"w\" . You will learn about mode later below.","title":"FileTextWrite"},{"location":"tutorial/parameter-types/file/#filebinaryread","text":"To read binary data you can use typer.FileBinaryRead . You will receive bytes from it. It's useful for reading binary files like images: import typer def main ( file : typer . FileBinaryRead = typer . Option ( ... )): processed_total = 0 for bytes_chunk in file : # Process the bytes in bytes_chunk processed_total += len ( bytes_chunk ) typer . echo ( f \"Processed bytes total: {processed_total} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --file lena.jpg Processed bytes total: 512 Processed bytes total: 1024 Processed bytes total: 1536 Processed bytes total: 2048","title":"FileBinaryRead"},{"location":"tutorial/parameter-types/file/#filebinarywrite","text":"To write binary data you can use typer.FileBinaryWrite . You would write bytes to it. It's useful for writing binary files like images. Have in mind that you have to pass bytes to its .write() method, not str . If you have a str , you have to encode it first to get bytes . import typer def main ( file : typer . FileBinaryWrite = typer . Option ( ... )): first_line_str = \"some settings \\n \" # You cannot write str directly to a binary file, you have to encode it to get bytes first_line_bytes = first_line_str . encode ( \"utf-8\" ) # Then you can write the bytes file . write ( first_line_bytes ) # This is already bytes, it starts with b\" second_line = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" file . write ( second_line ) typer . echo ( \"Binary file written\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py --file binary.dat Binary file written // Check the binary file was created $ ls ./binary.dat ./binary.dat","title":"FileBinaryWrite"},{"location":"tutorial/parameter-types/file/#file-cli-parameter-configurations","text":"You can use several configuration parameters for these types (classes) in typer.Option() and typer.Argument() : mode : controls the \" mode \" to open the file with. It's automatically set for you by using the classes above. Read more about it below. encoding : to force a specific encoding, e.g. \"utf-8\" . lazy : delay I/O operations. Automatic by default. By default, when writing files, Click will generate a file-like object that is not yet the actual file. Once you start writing, it will go, open the file and start writing to it, but not before. This is mainly useful to avoid creating the file until you start writing to it. It's normally safe to leave this automatic. But you can overwrite it setting lazy=False . By default, it's lazy=True for writing and lazy=False for reading. atomic : if true, all writes will actually go to a temporal file and then moved to the final destination after completing. This is useful with files modified frequently by several users/programs.","title":"File CLI parameter configurations"},{"location":"tutorial/parameter-types/file/#advanced-mode","text":"By default, Typer will configure the mode for you: typer.FileText : mode=\"r\" , to read text. typer.FileTextWrite : mode=\"w\" , to write text. typer.FileBinaryRead : mode=\"rb\" , to read binary data. typer.FileBinaryWrite : mode=\"wb\" , to write binary data.","title":"Advanced mode"},{"location":"tutorial/parameter-types/file/#note-about-filetextwrite","text":"typer.FileTextWrite is actually just a convenience class. It's the same as using typer.FileText with mode=\"w\" . But it's probably shorter and more intuitive as you can get it with autocompletion in your editor by just starting to type typer.File ... just like the other classes.","title":"Note about FileTextWrite"},{"location":"tutorial/parameter-types/file/#customize-mode","text":"You can override the mode from the defaults above. For example, you could use mode=\"a\" to write \"appending\" to the same file: import typer def main ( config : typer . FileText = typer . Option ( ... , mode = \"a\" )): config . write ( \"This is a single line \\n \" ) typer . echo ( \"Config line written\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip As you are manually setting mode=\"a\" , you can use typer.FileText or typer.FileTextWrite , both will work. Check it: $ python main.py --config config.txt Config line written // Run your program a couple more times to see how it appends instead of overwriting $ python main.py --config config.txt Config line written $ python main.py --config config.txt Config line written // Check the contents of the file, it should have each of the 3 lines appended $ cat config.txt This is a single line This is a single line This is a single line","title":"Customize mode"},{"location":"tutorial/parameter-types/file/#about-the-different-types","text":"Info These are technical details about why the different types/classes provided by Typer . But you don't need this information to be able to use them. You can skip it. Typer provides you these different types (classes) because they inherit directly from the actual Python implementation that will be provided underneath for each case. This way your editor will give you the right type checks and completion for each type. Even if you use lazy . When you use lazy Click creates a especial object to delay writes, and serves as a \"proxy\" to the actual file that will be written. But this especial proxy object doesn't expose the attributes and methods needed for type checks and completion in the editor. If you access those attributes or call the methods, the \"proxy\" lazy object will call them in the final object and it will all work. But you wouldn't get autocompletion for them. But because these Typer classes inherit from the actual implementation that will be provided underneath (not the lazy object), you will get all the autocompletion and type checks in the editor.","title":"About the different types"},{"location":"tutorial/parameter-types/number/","text":"You can define numeric validations with max and min values for int and float CLI parameters : import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), age : int = typer . Option ( 20 , min = 18 ), score : float = typer . Option ( 0 , max = 100 ), ): typer . echo ( f \"ID is {id} \" ) typer . echo ( f \"--age is {age} \" ) typer . echo ( f \"--score is {score} \" ) if __name__ == \"__main__\" : typer . run ( main ) CLI arguments and CLI options can both use these validations. You can specify min , max or both. Check it: $ python main.py --help // Notice the extra RANGE in the help text for --age and --score Usage: main.py [OPTIONS] ID Options: --age INTEGER RANGE --score FLOAT RANGE --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Pass all the CLI parameters $ python main.py 5 --age 20 --score 90 ID is 5 --age is 20 --score is 90.0 // Pass an invalid ID $ python main.py 1002 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for \"ID\": 1002 is not in the valid range of 0 to 1000. // Pass an invalid age $ python main.py 5 --age 15 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for \"--age\": 15 is smaller than the minimum valid value 18. // Pass an invalid score $ python main.py 5 --age 20 --score 100 .5 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for \"--score\": 100.5 is bigger than the maximum valid value 100. // But as we didn't specify a minimum score, this is accepted $ python main.py 5 --age 20 --score -5 ID is 5 --age is 20 --score is -5.0 Clamping numbers \u00b6 You might want to, instead of showing an error, use the closest minimum or maximum valid values. You can do it with the clamp parameter: import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), rank : int = typer . Option ( 0 , max = 10 , clamp = True ), score : float = typer . Option ( 0 , min = 0 , max = 100 , clamp = True ), ): typer . echo ( f \"ID is {id} \" ) typer . echo ( f \"--rank is {rank} \" ) typer . echo ( f \"--score is {score} \" ) if __name__ == \"__main__\" : typer . run ( main ) And then, when you pass data that is out of the valid range, it will be \"clamped\", the closest valid value will be used: // ID doesn't have clamp, so it shows an error $ python main.py 1002 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for \"ID\": 1002 is not in the valid range of 0 to 1000. // But --rank and --score use clamp $ python main.py 5 --rank 11 --score -5 ID is 5 --rank is 10 --score is 0 Counter CLI options \u00b6 You can make a CLI option work as a counter with the counter parameter: import typer def main ( verbose : int = typer . Option ( 0 , \"--verbose\" , \"-v\" , count = True )): typer . echo ( f \"Verbose level is {verbose} \" ) if __name__ == \"__main__\" : typer . run ( main ) It means that the CLI option will be like a boolean flag, e.g. --verbose . And the value you receive in the function will be the amount of times that --verbose was added: // Check it $ python main.py Verbose level is 0 // Now use one --verbose $ python main.py --verbose Verbose level is 1 // Now 3 --verbose $ python main.py --verbose --verbose --verbose Verbose level is 3 // And with the short name $ python main.py -v Verbose level is 1 // And with the short name 3 times $ python main.py -v -v -v Verbose level is 3 // As short names can be put together, this also works $ python main.py -vvv Verbose level is 3","title":"Number"},{"location":"tutorial/parameter-types/number/#clamping-numbers","text":"You might want to, instead of showing an error, use the closest minimum or maximum valid values. You can do it with the clamp parameter: import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), rank : int = typer . Option ( 0 , max = 10 , clamp = True ), score : float = typer . Option ( 0 , min = 0 , max = 100 , clamp = True ), ): typer . echo ( f \"ID is {id} \" ) typer . echo ( f \"--rank is {rank} \" ) typer . echo ( f \"--score is {score} \" ) if __name__ == \"__main__\" : typer . run ( main ) And then, when you pass data that is out of the valid range, it will be \"clamped\", the closest valid value will be used: // ID doesn't have clamp, so it shows an error $ python main.py 1002 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for \"ID\": 1002 is not in the valid range of 0 to 1000. // But --rank and --score use clamp $ python main.py 5 --rank 11 --score -5 ID is 5 --rank is 10 --score is 0","title":"Clamping numbers"},{"location":"tutorial/parameter-types/number/#counter-cli-options","text":"You can make a CLI option work as a counter with the counter parameter: import typer def main ( verbose : int = typer . Option ( 0 , \"--verbose\" , \"-v\" , count = True )): typer . echo ( f \"Verbose level is {verbose} \" ) if __name__ == \"__main__\" : typer . run ( main ) It means that the CLI option will be like a boolean flag, e.g. --verbose . And the value you receive in the function will be the amount of times that --verbose was added: // Check it $ python main.py Verbose level is 0 // Now use one --verbose $ python main.py --verbose Verbose level is 1 // Now 3 --verbose $ python main.py --verbose --verbose --verbose Verbose level is 3 // And with the short name $ python main.py -v Verbose level is 1 // And with the short name 3 times $ python main.py -v -v -v Verbose level is 3 // As short names can be put together, this also works $ python main.py -vvv Verbose level is 3","title":"Counter CLI options"},{"location":"tutorial/parameter-types/path/","text":"You can declare a CLI parameter to be a standard Python pathlib.Path . This is what you would do for directory paths, file paths, etc: from pathlib import Path import typer def main ( config : Path = typer . Option ( None )): if config is None : typer . echo ( \"No config file\" ) raise typer . Abort () if config . is_file (): text = config . read_text () typer . echo ( f \"Config file contents: {text} \" ) elif config . is_dir (): typer . echo ( \"Config is a directory, will use all its config files\" ) elif not config . exists (): typer . echo ( \"The config doesn't exist\" ) if __name__ == \"__main__\" : typer . run ( main ) And again, as you receive a standard Python Path object the same as the type annotation, your editor will give you autocompletion for all its attributes and methods. Check it: // No config $ python main.py No config file Aborted! // Pass a config that doesn't exist $ python main.py --config config.txt The config doesn't exist // Now create a quick config $ echo \"some settings\" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Config is a directory, will use all its config files Path validations \u00b6 You can perform several validations for Path CLI parameters : exists : if set to true, the file or directory needs to exist for this value to be valid. If this is not required and a file does indeed not exist, then all further checks are silently skipped. file_okay : controls if a file is a possible value. dir_okay : controls if a directory is a possible value. writable : if true, a writable check is performed. readable : if true, a readable check is performed. resolve_path : if this is true, then the path is fully resolved before the value is passed onwards. This means that it\u2019s absolute and symlinks are resolved. Technical Details It will not expand a tilde-prefix (something with ~ , like ~/Documents/ ), as this is supposed to be done by the shell only. Tip All these parameters come directly from Click . For example: from pathlib import Path import typer def main ( config : Path = typer . Option ( ... , exists = True , file_okay = True , dir_okay = False , writable = False , readable = True , resolve_path = True , ) ): text = config . read_text () typer . echo ( f \"Config file contents: {text} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --config config.txt Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for \"--config\": File \"config.txt\" does not exist. // Now create a quick config $ echo \"some settings\" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for \"--config\": File \"./\" is a directory. Advanced Path configurations \u00b6 Advanced Details You probably won't need these configurations at first, you may want to skip it. They are used for more advanced use cases. allow_dash : If this is set to True, a single dash to indicate standard streams is permitted. path_type : optionally a string type that should be used to represent the path. The default is None which means the return value will be either bytes or unicode depending on what makes most sense given the input data Click deals with.","title":"Path"},{"location":"tutorial/parameter-types/path/#path-validations","text":"You can perform several validations for Path CLI parameters : exists : if set to true, the file or directory needs to exist for this value to be valid. If this is not required and a file does indeed not exist, then all further checks are silently skipped. file_okay : controls if a file is a possible value. dir_okay : controls if a directory is a possible value. writable : if true, a writable check is performed. readable : if true, a readable check is performed. resolve_path : if this is true, then the path is fully resolved before the value is passed onwards. This means that it\u2019s absolute and symlinks are resolved. Technical Details It will not expand a tilde-prefix (something with ~ , like ~/Documents/ ), as this is supposed to be done by the shell only. Tip All these parameters come directly from Click . For example: from pathlib import Path import typer def main ( config : Path = typer . Option ( ... , exists = True , file_okay = True , dir_okay = False , writable = False , readable = True , resolve_path = True , ) ): text = config . read_text () typer . echo ( f \"Config file contents: {text} \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --config config.txt Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for \"--config\": File \"config.txt\" does not exist. // Now create a quick config $ echo \"some settings\" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for \"--config\": File \"./\" is a directory.","title":"Path validations"},{"location":"tutorial/parameter-types/path/#advanced-path-configurations","text":"Advanced Details You probably won't need these configurations at first, you may want to skip it. They are used for more advanced use cases. allow_dash : If this is set to True, a single dash to indicate standard streams is permitted. path_type : optionally a string type that should be used to represent the path. The default is None which means the return value will be either bytes or unicode depending on what makes most sense given the input data Click deals with.","title":"Advanced Path configurations"},{"location":"tutorial/parameter-types/uuid/","text":"Info A UUID is a \"Universally Unique Identifier\" . It's a standard format for identifiers, like passport numbers, but for anything, not just people in countries. They look like this: d48edaa6-871a-4082-a196-4daab372d4a1 The way they are generated makes them sufficiently long and random that you could assume that every UUID generated is unique. Even if it was generated by a different application, database, or system. So, if your system uses UUIDs to identify your data, you could mix it with the data from some other system that also uses UUIDs with some confidence that their IDs (UUIDs) won't clash with yours. This wouldn't be true if you just used int s as identifiers, as most databases do. You can declare a CLI parameter as a UUID: from uuid import UUID import typer def main ( user_id : UUID ): typer . echo ( f \"USER_ID is {user_id} \" ) typer . echo ( f \"UUID version is: {user_id.version} \" ) if __name__ == \"__main__\" : typer . run ( main ) Your Python code will receive a standard Python UUID object with all its attributes and methods, and as you are annotating your function parameter with that type, you will have type checks, autocompletion in your editor, etc. Check it: // Pass a valid UUID v4 $ python main.py d48edaa6-871a-4082-a196-4daab372d4a1 USER_ID is d48edaa6-871a-4082-a196-4daab372d4a1 UUID version is: 4 // An invalid value $ python main.py 7479706572 -72756c6573 Usage: main.py [OPTIONS] USER_ID Try \"main.py --help\" for help. Error: Invalid value for \"USER_ID\": 7479706572-72756c6573 is not a valid UUID value","title":"Uuid"},{"location":"tutorial/subcommands/","text":"You read before how to create a program with Commands . Now we'll see how to create a CLI program with commands that have their own subcommands. Also known as command groups. For example, the CLI program git has a command remote . But git remote , in turn, has its own subcommands, like add : // git remote alone shows the current remote repositories $ git remote origin // Use -v to make it verbose and show more info $ git remote -v origin git@github.com:yourusername/typer.git (fetch) origin git@github.com:yourusername/typer.git (push) // git remote add takes 2 CLI arguments, a name and URL $ git remote add upstream https://github.com/tiangolo/typer.git // Doesn't output anything, but now you have another remote repository called upstream // Now check again $ git remote -v origin git@github.com:yourusername/typer.git (fetch) origin git@github.com:yourusername/typer.git (push) upstream https://github.com/tiangolo/typer.git (fetch) upstream https://github.com/tiangolo/typer.git (push) In the next sections we'll see how to create subcommands like these.","title":"Home"},{"location":"tutorial/subcommands/add-typer/","text":"We'll start with the core idea. To add a typer.Typer() app inside of another. Manage items \u00b6 Let's imagine that you are creating a CLI program to manage items in some distant land. It could be in an items.py file with this: import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python items.py create Wand Creating item: Wand Manage users \u00b6 But then you realize that you also have to manage users from your CLI app . It could be a file users.py with something like: import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python users.py create Camila Creating user: Camila Put them together \u00b6 Both parts are similar. In fact, items.py and users.py both have commands create and delete . But we need them to be part of the same CLI program . In this case, as with git remote , we can put them together as subcommands in another typer.Typer() CLI program . Now create a main.py with: import typer import items import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) if __name__ == \"__main__\" : app () Here's what we do in main.py : Import the other Python modules (the files users.py and items.py ). Create the main typer.Typer() application. Use app.add_typer() to include the app from items.py and users.py , each of those 2 was also created with typer.Typer() . Define a name with the command that will be used for each of these \"sub-Typers\" to group their own commands. And now your CLI program has 2 commands: users : with all of the commands (subcommands) in the app from users.py . items with all the commands (subcommands) in the app from items.py . Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Now you have a CLI program with commands items and users , and they in turn have their own commands (subcommands). Let's check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase Tip Notice that we are still calling $ python main.py but now we are using the command items . And now check the command users , with all its subcommands: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila Recap \u00b6 That's the core idea. You can just create typer.Typer() apps and add them inside one another. And you can do that with any levels of commands that you want. Do you need sub-sub-sub-subcommands? Go ahead, create all the typer.Typer() s you need and put them together with app.add_typer() . In the next sections we'll update this with more features, but you already have the core idea. This way, in the same spirit of Click, Typer applications are composable, each typer.Typer() can be a CLI app by itself, but it can also be added as a command group to another Typer app.","title":"Add typer"},{"location":"tutorial/subcommands/add-typer/#manage-items","text":"Let's imagine that you are creating a CLI program to manage items in some distant land. It could be in an items.py file with this: import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python items.py create Wand Creating item: Wand","title":"Manage items"},{"location":"tutorial/subcommands/add-typer/#manage-users","text":"But then you realize that you also have to manage users from your CLI app . It could be a file users.py with something like: import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python users.py create Camila Creating user: Camila","title":"Manage users"},{"location":"tutorial/subcommands/add-typer/#put-them-together","text":"Both parts are similar. In fact, items.py and users.py both have commands create and delete . But we need them to be part of the same CLI program . In this case, as with git remote , we can put them together as subcommands in another typer.Typer() CLI program . Now create a main.py with: import typer import items import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) if __name__ == \"__main__\" : app () Here's what we do in main.py : Import the other Python modules (the files users.py and items.py ). Create the main typer.Typer() application. Use app.add_typer() to include the app from items.py and users.py , each of those 2 was also created with typer.Typer() . Define a name with the command that will be used for each of these \"sub-Typers\" to group their own commands. And now your CLI program has 2 commands: users : with all of the commands (subcommands) in the app from users.py . items with all the commands (subcommands) in the app from items.py . Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Now you have a CLI program with commands items and users , and they in turn have their own commands (subcommands). Let's check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase Tip Notice that we are still calling $ python main.py but now we are using the command items . And now check the command users , with all its subcommands: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila","title":"Put them together"},{"location":"tutorial/subcommands/add-typer/#recap","text":"That's the core idea. You can just create typer.Typer() apps and add them inside one another. And you can do that with any levels of commands that you want. Do you need sub-sub-sub-subcommands? Go ahead, create all the typer.Typer() s you need and put them together with app.add_typer() . In the next sections we'll update this with more features, but you already have the core idea. This way, in the same spirit of Click, Typer applications are composable, each typer.Typer() can be a CLI app by itself, but it can also be added as a command group to another Typer app.","title":"Recap"},{"location":"tutorial/subcommands/callback-override/","text":"When creating a Typer app you can define a callback function, it always executes and defines the CLI arguments and CLI options that go before a command. When adding a Typer app inside of another, the sub-Typer can also have its own callback. It can handle any CLI parameters that go before its own commands and execute any extra code: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @users_app . callback () def users_callback (): typer . echo ( \"Running a users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () In this case it doesn't define any CLI parameters , it just writes a message. Check it: $ python main.py users create Camila // Notice the first message is not created by the command function but by the callback Running a users command Creating user: Camila Add a callback on creation \u00b6 It's also possible to add a callback when creating the typer.Typer() app that will be added to another Typer app: import typer app = typer . Typer () def users_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = users_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as above, it's just another place to add the callback. Check it: $ python main.py users create Camila Running a users command Creating user: Camila Overriding the callback on creation \u00b6 If a callback was added when creating the typer.Typer() app, it's possible to override it with a new one using @app.callback() . This is the same information you saw on the section about Commands - Typer Callback , and it applies the same for sub-Typer apps: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Here we had defined a callback when creating the typer.Typer() sub-app, but then we override it with a new callback with the function user_callback() . As @app.callback() takes precedence over typer.Typer(callback=some_function) , now our CLI app will use this new callback. Check it: $ python main.py users create Camila // Notice the message from the new callback Callback override, running users command Creating user: Camila Overriding the callback when adding a sub-Typer \u00b6 Lastly, you can override the callback defined anywhere else when adding a sub-Typer with app.add_typer() using the callback parameter. This has the highest priority: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) def callback_for_add_typer (): typer . echo ( \"I have the high land! Running users command\" ) app . add_typer ( users_app , name = \"users\" , callback = callback_for_add_typer ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Notice that the precedence goes to app.add_typer() and is not affected by the order of execution. There's another callback defined below, but the one from app.add_typer() wins. Now when you use the CLI program it will use the new callback function callback_for_add_typer() . Check it: $ python users create Camila // Notice the message from the callback added in add_typer() I have the high land! Running users command Creating user: Camila","title":"Callback override"},{"location":"tutorial/subcommands/callback-override/#add-a-callback-on-creation","text":"It's also possible to add a callback when creating the typer.Typer() app that will be added to another Typer app: import typer app = typer . Typer () def users_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = users_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as above, it's just another place to add the callback. Check it: $ python main.py users create Camila Running a users command Creating user: Camila","title":"Add a callback on creation"},{"location":"tutorial/subcommands/callback-override/#overriding-the-callback-on-creation","text":"If a callback was added when creating the typer.Typer() app, it's possible to override it with a new one using @app.callback() . This is the same information you saw on the section about Commands - Typer Callback , and it applies the same for sub-Typer apps: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Here we had defined a callback when creating the typer.Typer() sub-app, but then we override it with a new callback with the function user_callback() . As @app.callback() takes precedence over typer.Typer(callback=some_function) , now our CLI app will use this new callback. Check it: $ python main.py users create Camila // Notice the message from the new callback Callback override, running users command Creating user: Camila","title":"Overriding the callback on creation"},{"location":"tutorial/subcommands/callback-override/#overriding-the-callback-when-adding-a-sub-typer","text":"Lastly, you can override the callback defined anywhere else when adding a sub-Typer with app.add_typer() using the callback parameter. This has the highest priority: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) def callback_for_add_typer (): typer . echo ( \"I have the high land! Running users command\" ) app . add_typer ( users_app , name = \"users\" , callback = callback_for_add_typer ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Notice that the precedence goes to app.add_typer() and is not affected by the order of execution. There's another callback defined below, but the one from app.add_typer() wins. Now when you use the CLI program it will use the new callback function callback_for_add_typer() . Check it: $ python users create Camila // Notice the message from the callback added in add_typer() I have the high land! Running users command Creating user: Camila","title":"Overriding the callback when adding a sub-Typer"},{"location":"tutorial/subcommands/name-and-help/","text":"When adding a Typer app to another we have seen how to set the name to use for the command. For example to set the command to users : app . add_typer ( users . app , name = \"users\" ) Add a help text \u00b6 We can also set the help while adding a Typer: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" , help = \"Manage users in the app.\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () And then we get that help text for that command in the CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create We can set the name and help in several places, each one taking precedence over the other, overriding the previous value. Let's see those locations. Tip There are other attributes that can be set in that same way in the same places we'll see next. But those are documented later in another section. Inferring name and help from callback \u00b6 Inferring a command's name and help \u00b6 When you create a command with @app.command() , by default, it generates the name from the function name. And by default, the help text is extracted from the function's docstring. For example: @app . command () def create ( item : str ): \"\"\" Create an item. \"\"\" typer . echo ( f \"Creating item: {item} \" ) ...will create a command create with a help text of Create an item . Inferring name and help from @app.callback() \u00b6 The same way, if you define a callback in a typer.Typer() , the help text is extracted from the callback function's docstring. And if that Typer app is added to another Typer app, the default name of the command is generated from the name of the callback function. Here's an example: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Notice that now we added the sub-Typer without specifying a name nor a help . They are now inferred from the callback function. The command name will be the same callback function's name: users . And the help text for that users command will be the callback function's docstring: Manage users in the app. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create Name and help from callback parameter in typer.Typer() \u00b6 If you pass a callback parameter while creating a typer.Typer(callback=some_function) it will be used to infer the name and help text. This has the lowest priority, we'll see later what has a higher priority and can override it. Check the code: import typer app = typer . Typer () def users (): \"\"\" Manage users in the app. \"\"\" users_app = typer . Typer ( callback = users ) app . add_typer ( users_app ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as the previous example. Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create Override a callback set in typer.Typer() with @app.callback() \u00b6 The same as with normal Typer apps, if you pass a callback to typer.Typer(callback=some_function) and then override it with @app.callback() , the name and help text will be inferred from the new callback: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now the name of the command will be users instead of old-callback , and the help text will be Manage users in the app. instead of Old callback help. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create Infer name and help from callback in app.add_typer() \u00b6 If you override the callback in app.add_typer() when including a sub-app, the name and help will be inferred from this callback function. This takes precedence over inferring the name and help from a callback set in @sub_app.callback() and typer.Typer(callback=sub_app_callback) . Check the code: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now the command will be new-users instead of users . And the help text will be I have the highland! Create some users. instead of the previous ones. Check it: // Check the main help $ python main.py --help // Check the command new-users and its help text Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: new-users I have the highland! Create some users. // Now check the help for the new-users command $ python main.py new-users --help // Notice the help text Usage: main.py new-users [OPTIONS] COMMAND [ARGS]... I have the highland! Create some users. Options: --help Show this message and exit. Commands: create Enough inferring \u00b6 So, when inferring a name and help text, the precedence order from lowest priority to highest is: sub_app = typer.Typer(callback=some_function) @sub_app.callback() app.add_typer(sub_app, callback=new_function) That's for inferring the name and help text from functions. But if you set the name and help text explicitly, that has a higher priority than these. Set the name and help \u00b6 Let's now see the places where you can set the command name and help text, from lowest priority to highest. Tip Setting the name and help text explicitly always has a higher precedence than inferring from a callback function. Name and help in typer.Typer() \u00b6 You could have all the callbacks and overrides we defined before, but the name and help text was inferred from the function name and docstring. If you set it explicitly, that takes precedence over inferring. You can set it when creating a new typer.Typer() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Info The rest of the callbacks and overrides are there only to show you that they don't affect the name and help text when you set it explicitly. We set an explicit name exp-users , and an explicit help Explicit help. . So that will take precedence now. Check it: // Check the main help $ python main.py --help // Notice the command name is exp-users and the help text is \"Explicit help.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: exp-users Explicit help. // Check the help for the exp-users command $ python main.py exp-users --help // Notice the main help text Usage: main.py exp-users [OPTIONS] COMMAND [ARGS]... Explicit help. Options: --help Show this message and exit. Commands: create Name and help in @app.callback() \u00b6 Any parameter that you use when creating a typer.Typer() app can be overridden in the parameters of @app.callback() . Continuing with the previous example, we now override the values in @user_app.callback() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () And now the command name will be call-users and the help text will be Help from callback for users. . Check it: // Check the help $ python main.py --help // The command name now is call-users and the help text is \"Help from callback for users.\". Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: call-users Help from callback for users. // Check the call-users command help $ python main.py call-users --help // Notice the main help text Usage: main.py call-users [OPTIONS] COMMAND [ARGS]... Help from callback for users. Options: --help Show this message and exit. Commands: create Name and help in app.add_typer() \u00b6 And finally, with the highest priority, you can override all that by explicitly setting the name and help in app.add_typer() , just like we did on the first example above: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users , name = \"cake-sith-users\" , help = \"Unlimited powder! Eh, users.\" , ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () And now, with the highest priorities of them all, the command name will now be cake-sith-users and the help text will be Unlimited powder! Eh, users. . Check it: // Check the help $ python main.py --help // Notice the command name cake-sith-users and the new help text \"Unlimited powder! Eh, users.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: cake-sith-users Unlimited powder! Eh, users. // And check the help for the command cake-sith-users $ python main.py cake-sith-users --help // Notice the main help text Usage: main.py cake-sith-users [OPTIONS] COMMAND [ARGS]... Unlimited powder! Eh, users. Options: --help Show this message and exit. Commands: create Recap \u00b6 The precedence to generate a command's name and help, from lowest priority to highest, is: Implicitly inferred from sub_app = typer.Typer(callback=some_function) Implicitly inferred from the callback function under @sub_app.callback() Implicitly inferred from app.add_typer(sub_app, callback=some_function) Explicitly set on sub_app = typer.Typer(name=\"some-name\", help=\"Some help.\") Explicitly set on @sub_app.callback(\"some-name\", help=\"Some help.\") Explicitly set on app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") So, app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") always wins.","title":"Name and help"},{"location":"tutorial/subcommands/name-and-help/#add-a-help-text","text":"We can also set the help while adding a Typer: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" , help = \"Manage users in the app.\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () And then we get that help text for that command in the CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create We can set the name and help in several places, each one taking precedence over the other, overriding the previous value. Let's see those locations. Tip There are other attributes that can be set in that same way in the same places we'll see next. But those are documented later in another section.","title":"Add a help text"},{"location":"tutorial/subcommands/name-and-help/#inferring-name-and-help-from-callback","text":"","title":"Inferring name and help from callback"},{"location":"tutorial/subcommands/name-and-help/#inferring-a-commands-name-and-help","text":"When you create a command with @app.command() , by default, it generates the name from the function name. And by default, the help text is extracted from the function's docstring. For example: @app . command () def create ( item : str ): \"\"\" Create an item. \"\"\" typer . echo ( f \"Creating item: {item} \" ) ...will create a command create with a help text of Create an item .","title":"Inferring a command's name and help"},{"location":"tutorial/subcommands/name-and-help/#inferring-name-and-help-from-appcallback","text":"The same way, if you define a callback in a typer.Typer() , the help text is extracted from the callback function's docstring. And if that Typer app is added to another Typer app, the default name of the command is generated from the name of the callback function. Here's an example: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Notice that now we added the sub-Typer without specifying a name nor a help . They are now inferred from the callback function. The command name will be the same callback function's name: users . And the help text for that users command will be the callback function's docstring: Manage users in the app. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create","title":"Inferring name and help from @app.callback()"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-from-callback-parameter-in-typertyper","text":"If you pass a callback parameter while creating a typer.Typer(callback=some_function) it will be used to infer the name and help text. This has the lowest priority, we'll see later what has a higher priority and can override it. Check the code: import typer app = typer . Typer () def users (): \"\"\" Manage users in the app. \"\"\" users_app = typer . Typer ( callback = users ) app . add_typer ( users_app ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as the previous example. Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create","title":"Name and help from callback parameter in typer.Typer()"},{"location":"tutorial/subcommands/name-and-help/#override-a-callback-set-in-typertyper-with-appcallback","text":"The same as with normal Typer apps, if you pass a callback to typer.Typer(callback=some_function) and then override it with @app.callback() , the name and help text will be inferred from the new callback: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now the name of the command will be users instead of old-callback , and the help text will be Manage users in the app. instead of Old callback help. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create","title":"Override a callback set in typer.Typer() with @app.callback()"},{"location":"tutorial/subcommands/name-and-help/#infer-name-and-help-from-callback-in-appadd_typer","text":"If you override the callback in app.add_typer() when including a sub-app, the name and help will be inferred from this callback function. This takes precedence over inferring the name and help from a callback set in @sub_app.callback() and typer.Typer(callback=sub_app_callback) . Check the code: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Now the command will be new-users instead of users . And the help text will be I have the highland! Create some users. instead of the previous ones. Check it: // Check the main help $ python main.py --help // Check the command new-users and its help text Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: new-users I have the highland! Create some users. // Now check the help for the new-users command $ python main.py new-users --help // Notice the help text Usage: main.py new-users [OPTIONS] COMMAND [ARGS]... I have the highland! Create some users. Options: --help Show this message and exit. Commands: create","title":"Infer name and help from callback in app.add_typer()"},{"location":"tutorial/subcommands/name-and-help/#enough-inferring","text":"So, when inferring a name and help text, the precedence order from lowest priority to highest is: sub_app = typer.Typer(callback=some_function) @sub_app.callback() app.add_typer(sub_app, callback=new_function) That's for inferring the name and help text from functions. But if you set the name and help text explicitly, that has a higher priority than these.","title":"Enough inferring"},{"location":"tutorial/subcommands/name-and-help/#set-the-name-and-help","text":"Let's now see the places where you can set the command name and help text, from lowest priority to highest. Tip Setting the name and help text explicitly always has a higher precedence than inferring from a callback function.","title":"Set the name and help"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-in-typertyper","text":"You could have all the callbacks and overrides we defined before, but the name and help text was inferred from the function name and docstring. If you set it explicitly, that takes precedence over inferring. You can set it when creating a new typer.Typer() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () Info The rest of the callbacks and overrides are there only to show you that they don't affect the name and help text when you set it explicitly. We set an explicit name exp-users , and an explicit help Explicit help. . So that will take precedence now. Check it: // Check the main help $ python main.py --help // Notice the command name is exp-users and the help text is \"Explicit help.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: exp-users Explicit help. // Check the help for the exp-users command $ python main.py exp-users --help // Notice the main help text Usage: main.py exp-users [OPTIONS] COMMAND [ARGS]... Explicit help. Options: --help Show this message and exit. Commands: create","title":"Name and help in typer.Typer()"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-in-appcallback","text":"Any parameter that you use when creating a typer.Typer() app can be overridden in the parameters of @app.callback() . Continuing with the previous example, we now override the values in @user_app.callback() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () And now the command name will be call-users and the help text will be Help from callback for users. . Check it: // Check the help $ python main.py --help // The command name now is call-users and the help text is \"Help from callback for users.\". Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: call-users Help from callback for users. // Check the call-users command help $ python main.py call-users --help // Notice the main help text Usage: main.py call-users [OPTIONS] COMMAND [ARGS]... Help from callback for users. Options: --help Show this message and exit. Commands: create","title":"Name and help in @app.callback()"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-in-appadd_typer","text":"And finally, with the highest priority, you can override all that by explicitly setting the name and help in app.add_typer() , just like we did on the first example above: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users , name = \"cake-sith-users\" , help = \"Unlimited powder! Eh, users.\" , ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: {name} \" ) if __name__ == \"__main__\" : app () And now, with the highest priorities of them all, the command name will now be cake-sith-users and the help text will be Unlimited powder! Eh, users. . Check it: // Check the help $ python main.py --help // Notice the command name cake-sith-users and the new help text \"Unlimited powder! Eh, users.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: cake-sith-users Unlimited powder! Eh, users. // And check the help for the command cake-sith-users $ python main.py cake-sith-users --help // Notice the main help text Usage: main.py cake-sith-users [OPTIONS] COMMAND [ARGS]... Unlimited powder! Eh, users. Options: --help Show this message and exit. Commands: create","title":"Name and help in app.add_typer()"},{"location":"tutorial/subcommands/name-and-help/#recap","text":"The precedence to generate a command's name and help, from lowest priority to highest, is: Implicitly inferred from sub_app = typer.Typer(callback=some_function) Implicitly inferred from the callback function under @sub_app.callback() Implicitly inferred from app.add_typer(sub_app, callback=some_function) Explicitly set on sub_app = typer.Typer(name=\"some-name\", help=\"Some help.\") Explicitly set on @sub_app.callback(\"some-name\", help=\"Some help.\") Explicitly set on app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") So, app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") always wins.","title":"Recap"},{"location":"tutorial/subcommands/nested-subcommands/","text":"We'll now see how these same ideas can be extended for deeply nested commands. Let's imagine that the same CLI program from the previous examples now needs to handle lands . But a land could be a reign or town . And each of those could have their own commands, like create and delete . A CLI app for reigns \u00b6 Let's start with a file reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: {name} \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: {name} \" ) if __name__ == \"__main__\" : app () This is already a simple CLI program to manage reigns: // Check the help $ python reigns.py --help Usage: reigns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: conquer destroy // Try it $ python reigns.py conquer Cintra Conquering reign: Cintra $ python reigns.py destroy Mordor Destroying reign: Mordor A CLI app for towns \u00b6 And now the equivalent for managing towns in towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: {name} \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: {name} \" ) if __name__ == \"__main__\" : app () With it, you can manage towns: // Check the help $ python towns.py --help Usage: towns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: burn found // Try it $ python towns.py found \"New Asgard\" Founding town: New Asgard $ python towns.py burn Vizima Burning town: Vizima Manage the land in a CLI app \u00b6 Now let's put the reigns and towns together in the same CLI program in lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () And now we have a single CLI program with a command (or command group) reigns that has its own commands. And another command towns with its own subcommands. Check it: // Check the help $ python lands.py --help Usage: lands.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: reigns towns // We still have the help for reigns $ python lands.py reigns --help Usage: lands.py reigns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: conquer destroy // And the help for towns $ python lands.py towns --help Usage: lands.py towns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: burn found Now try it, manage the lands through the CLI: // Try the reigns command $ python lands.py reigns conquer Gondor Conquering reign: Gondor $ python lands.py reigns destroy Nilfgaard Destroying reign: Nilfgaard // Try the towns command $ python lands.py towns found Springfield Founding town: Springfield $ python lands.py towns burn Atlantis Burning town: Atlantis Deeply nested subcommands \u00b6 Now let's say that all these commands in the lands.py CLI program should be part of the previous CLI program we built in the first example. We want our CLI program to have these commands/command groups: users : create delete items : create delete sell lands : reigns : conquer destroy towns : found burn This already is a quite deeply nested \"tree\" of commands/command groups. But to achieve that, we just have to add the lands Typer app to the same main.py file we already had: import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () And now we have everything in a single CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items lands users // Try some users commands $ python main.py users create Camila Creating user: Camila // Now try some items commands $ python main.py items create Sword Creating item: Sword // And now some lands commands for reigns $ python main.py lands reigns conquer Gondor Conquering reign: Gondor // And for towns $ python main.py lands towns found Cartagena Founding town: Cartagena Review the files \u00b6 Here are all the files if you want to review/copy them: reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: {name} \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: {name} \" ) if __name__ == \"__main__\" : app () towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: {name} \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: {name} \" ) if __name__ == \"__main__\" : app () lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () users.py : import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () items.py : import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) if __name__ == \"__main__\" : app () main.py : import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () Tip All these files have an if __name__ == \"__main__\" block just to demonstrate how each of them can also be an independent CLI app . But for your final application, only main.py would need it. Recap \u00b6 That's it, you can just add Typer applications one inside another as much as you want and create complex CLI programs while writing simple code. You can probably achieve a simpler CLI program design that's easier to use than the example here. But if your requirements are complex, Typer helps you build your CLI app easily. Tip Auto completion helps a lot, specially with complex programs. Check the docs about adding auto completion to your CLI apps .","title":"Nested subcommands"},{"location":"tutorial/subcommands/nested-subcommands/#a-cli-app-for-reigns","text":"Let's start with a file reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: {name} \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: {name} \" ) if __name__ == \"__main__\" : app () This is already a simple CLI program to manage reigns: // Check the help $ python reigns.py --help Usage: reigns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: conquer destroy // Try it $ python reigns.py conquer Cintra Conquering reign: Cintra $ python reigns.py destroy Mordor Destroying reign: Mordor","title":"A CLI app for reigns"},{"location":"tutorial/subcommands/nested-subcommands/#a-cli-app-for-towns","text":"And now the equivalent for managing towns in towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: {name} \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: {name} \" ) if __name__ == \"__main__\" : app () With it, you can manage towns: // Check the help $ python towns.py --help Usage: towns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: burn found // Try it $ python towns.py found \"New Asgard\" Founding town: New Asgard $ python towns.py burn Vizima Burning town: Vizima","title":"A CLI app for towns"},{"location":"tutorial/subcommands/nested-subcommands/#manage-the-land-in-a-cli-app","text":"Now let's put the reigns and towns together in the same CLI program in lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () And now we have a single CLI program with a command (or command group) reigns that has its own commands. And another command towns with its own subcommands. Check it: // Check the help $ python lands.py --help Usage: lands.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: reigns towns // We still have the help for reigns $ python lands.py reigns --help Usage: lands.py reigns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: conquer destroy // And the help for towns $ python lands.py towns --help Usage: lands.py towns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: burn found Now try it, manage the lands through the CLI: // Try the reigns command $ python lands.py reigns conquer Gondor Conquering reign: Gondor $ python lands.py reigns destroy Nilfgaard Destroying reign: Nilfgaard // Try the towns command $ python lands.py towns found Springfield Founding town: Springfield $ python lands.py towns burn Atlantis Burning town: Atlantis","title":"Manage the land in a CLI app"},{"location":"tutorial/subcommands/nested-subcommands/#deeply-nested-subcommands","text":"Now let's say that all these commands in the lands.py CLI program should be part of the previous CLI program we built in the first example. We want our CLI program to have these commands/command groups: users : create delete items : create delete sell lands : reigns : conquer destroy towns : found burn This already is a quite deeply nested \"tree\" of commands/command groups. But to achieve that, we just have to add the lands Typer app to the same main.py file we already had: import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () And now we have everything in a single CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items lands users // Try some users commands $ python main.py users create Camila Creating user: Camila // Now try some items commands $ python main.py items create Sword Creating item: Sword // And now some lands commands for reigns $ python main.py lands reigns conquer Gondor Conquering reign: Gondor // And for towns $ python main.py lands towns found Cartagena Founding town: Cartagena","title":"Deeply nested subcommands"},{"location":"tutorial/subcommands/nested-subcommands/#review-the-files","text":"Here are all the files if you want to review/copy them: reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: {name} \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: {name} \" ) if __name__ == \"__main__\" : app () towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: {name} \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: {name} \" ) if __name__ == \"__main__\" : app () lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () users.py : import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () items.py : import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) if __name__ == \"__main__\" : app () main.py : import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () Tip All these files have an if __name__ == \"__main__\" block just to demonstrate how each of them can also be an independent CLI app . But for your final application, only main.py would need it.","title":"Review the files"},{"location":"tutorial/subcommands/nested-subcommands/#recap","text":"That's it, you can just add Typer applications one inside another as much as you want and create complex CLI programs while writing simple code. You can probably achieve a simpler CLI program design that's easier to use than the example here. But if your requirements are complex, Typer helps you build your CLI app easily. Tip Auto completion helps a lot, specially with complex programs. Check the docs about adding auto completion to your CLI apps .","title":"Recap"},{"location":"tutorial/subcommands/single-file/","text":"In some cases, it's possible that your application code needs to live on a single file. You can still use the same ideas: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () There are several things to notice here... Apps at the top \u00b6 First, you can create typer.Typer() objects and add them to another one at the top. It doesn't have to be done after creating the subcommands: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () You can add the commands (subcommands) to each typer.Typer() app later and it will still work. Function names \u00b6 As you now have subcommands like create for users and for items , you can no longer call the functions with just the name, like def create() , because they would overwrite each other. So we use longer names: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () Command name \u00b6 We are naming the functions with longer names so that they don't overwrite each other. But we still want the subcommands to be create , delete , etc. To call them like: // We want this \u2714\ufe0f $ python main.py items create instead of: // We don't want this \u26d4\ufe0f $ python main.py items items-create So we pass the name we want to use for each subcommand as the function argument to the decorator: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () Check it \u00b6 It still works the same: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase And the same for the users command: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila","title":"Single file"},{"location":"tutorial/subcommands/single-file/#apps-at-the-top","text":"First, you can create typer.Typer() objects and add them to another one at the top. It doesn't have to be done after creating the subcommands: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app () You can add the commands (subcommands) to each typer.Typer() app later and it will still work.","title":"Apps at the top"},{"location":"tutorial/subcommands/single-file/#function-names","text":"As you now have subcommands like create for users and for items , you can no longer call the functions with just the name, like def create() , because they would overwrite each other. So we use longer names: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app ()","title":"Function names"},{"location":"tutorial/subcommands/single-file/#command-name","text":"We are naming the functions with longer names so that they don't overwrite each other. But we still want the subcommands to be create , delete , etc. To call them like: // We want this \u2714\ufe0f $ python main.py items create instead of: // We don't want this \u26d4\ufe0f $ python main.py items items-create So we pass the name we want to use for each subcommand as the function argument to the decorator: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: {item} \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: {item} \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: {item} \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: {user_name} \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: {user_name} \" ) if __name__ == \"__main__\" : app ()","title":"Command name"},{"location":"tutorial/subcommands/single-file/#check-it","text":"It still works the same: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase And the same for the users command: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila","title":"Check it"}]}